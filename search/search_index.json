{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"00-Intro/01_Start/","text":"Intro Before we get started with the training, we start with a short round of introductions. It would be helpful if you could briefly say something about the following points Introduce yourself briefly What are your expectations for today What are your expectations for today How much experience do you have with DAX and the tabular model? who is next?","title":"Intro"},{"location":"00-Intro/01_Start/#intro","text":"Before we get started with the training, we start with a short round of introductions. It would be helpful if you could briefly say something about the following points Introduce yourself briefly What are your expectations for today What are your expectations for today How much experience do you have with DAX and the tabular model? who is next?","title":"Intro"},{"location":"00-Intro/02_Agenda%20copy/","text":"Agenda These are our topics for today. Due to the tight time frame, we may adjust the focus according to need. In addition to some theory, the main focus is on solving practical exercises.","title":"Agenda"},{"location":"00-Intro/02_Agenda%20copy/#agenda","text":"These are our topics for today. Due to the tight time frame, we may adjust the focus according to need. In addition to some theory, the main focus is on solving practical exercises.","title":"Agenda"},{"location":"00-Intro/03_Tool_and_Documentation/","text":"Documentation and Development Tools The most important sources Here you will find the most important pages and books you need to become a true DAX expert. Definitive Guide to DAX In this book by Marco Russo and Alberto Ferrari you will find all information about DAX and the Tabular model. In addition to the DAX concepts and useful example calculations, the book also provides technical background on the tabular model. Justifiably, this book is considered the bible for every DAX expert. SQL BI Link_SqlBI On this website of Marco Russo and Alberto Ferrari you will find many useful articles about Dax and Tabular Model. There are also many useful download links to tools that might be interesting for you. Dax Patterns Link_DaxPatterns.com The next useful page from Marco and Alberto. Here, the two have taken the effort to create a template for the most common used cases. A look at this page is always worthwhile if you have to solve common problems. DAX Guide Link_DaxGuide ot surprisingly, the last page is also from the guys at SqlBi. With the Dax guide they have created a very useful documentation of all the DAX formulas. Especially useful are the linked videos and blog posts, as well as all the additional information such as the necessary compatibility level of the tabular engine. Development Tools In the world of taublar modeling, there are now many useful tools. This is not least because practically anyone can develop their own tool and embed it in Power Bi. In the world of taublar modeling, there are now many useful tools. This is not least because practically anyone can develop their own tool and embed it in Power Bi. Power BI Desktop Download_PowerBI DAX Studio Download_DaxStudio Tabular Editor Download_DaxStudio","title":"Documentation and Development Tools"},{"location":"00-Intro/03_Tool_and_Documentation/#documentation-and-development-tools","text":"","title":"Documentation and Development Tools"},{"location":"00-Intro/03_Tool_and_Documentation/#the-most-important-sources","text":"Here you will find the most important pages and books you need to become a true DAX expert. Definitive Guide to DAX In this book by Marco Russo and Alberto Ferrari you will find all information about DAX and the Tabular model. In addition to the DAX concepts and useful example calculations, the book also provides technical background on the tabular model. Justifiably, this book is considered the bible for every DAX expert.","title":"The most important sources"},{"location":"00-Intro/03_Tool_and_Documentation/#sql-bi","text":"Link_SqlBI On this website of Marco Russo and Alberto Ferrari you will find many useful articles about Dax and Tabular Model. There are also many useful download links to tools that might be interesting for you.","title":"SQL BI "},{"location":"00-Intro/03_Tool_and_Documentation/#dax-patterns","text":"Link_DaxPatterns.com The next useful page from Marco and Alberto. Here, the two have taken the effort to create a template for the most common used cases. A look at this page is always worthwhile if you have to solve common problems.","title":"Dax Patterns "},{"location":"00-Intro/03_Tool_and_Documentation/#dax-guide","text":"Link_DaxGuide ot surprisingly, the last page is also from the guys at SqlBi. With the Dax guide they have created a very useful documentation of all the DAX formulas. Especially useful are the linked videos and blog posts, as well as all the additional information such as the necessary compatibility level of the tabular engine.","title":"DAX Guide "},{"location":"00-Intro/03_Tool_and_Documentation/#development-tools","text":"In the world of taublar modeling, there are now many useful tools. This is not least because practically anyone can develop their own tool and embed it in Power Bi. In the world of taublar modeling, there are now many useful tools. This is not least because practically anyone can develop their own tool and embed it in Power Bi.","title":"Development Tools"},{"location":"00-Intro/03_Tool_and_Documentation/#power-bi-desktop","text":"Download_PowerBI","title":"Power BI Desktop "},{"location":"00-Intro/03_Tool_and_Documentation/#dax-studio","text":"Download_DaxStudio","title":"DAX Studio "},{"location":"00-Intro/03_Tool_and_Documentation/#tabular-editor","text":"Download_DaxStudio","title":"Tabular Editor "},{"location":"01-KeyConcepts/01_EvaluationContext/","text":"Evaluation Context Evaluation Context is: The environment in which a DAX formula is evaluated in. So, when we write a DAX formula it gets evaluated within an environment. The DAX formula evaluated will be directly dependant on the Evaluation Context. This means the result returned can be different depending on the context, even if the DAX formula used is the same. If this is your first read on Evaluation Context, you may be wondering why it is possible to get different results when using the same DAX formula. Let\u2019s make sure we make this clear before moving on. Take a look at the below measure: Profit = SUM(Sales[SalesAmount]) - SUM(Sales[TotalCost]) What types of Evaluation Context exist? There are only two different types of Evaluation Context. The Filter Context and the Row Context . Let's take a closer look at both of them, since they form the foundation of the DAX Engine. What is the diffrence? The filter context filters data, whereas the row context iterates tables. When DAX is iterating, it is not filtering; and when it is filtering, it is not iterating Filter-Context DAX evaluates all formulas within a respective context. Even though the formula is the same, the result is different because DAX executes the same code against different subsets of data. This context is named Filter Context and, as the name suggests, it is a context that filters tables. All DAX expressions are evaluated inside a context. The purpose of the filter context is, as its name implies, to filter tables. Filter context executes DAX code against a subset of Data Visual interactions in Power BI creates such a context Row-Context The Row-Context is not a tool to filter tables, like the Filter-Context. Instead, it is used to interate over tables and evaluate column values. Here is an example using a calculated column Sales[Gross Margin] = Sales[Quantity] * ( Sales[Net Price] - Sales[Unit Cost] ) As expected, for each row of the table there is a different value in the calculated column. Indeed, because there are given values in each row for the three columns used in the expression, it comes as a natural consequence that the fi nal expression computes different values. As it happened with the filter context, the reason is the presence of an evaluation context. This time, the context does not filter a table. Instead, it identifies the row for which the calculation happens. The row context references a row in the result of a DAX table expression Calculated columns always act in a row context A row in a report is not a row context To create a row context in a DAX-Formula use one of the X-Function like SUMX","title":"Evaluation Context"},{"location":"01-KeyConcepts/01_EvaluationContext/#evaluation-context","text":"Evaluation Context is: The environment in which a DAX formula is evaluated in. So, when we write a DAX formula it gets evaluated within an environment. The DAX formula evaluated will be directly dependant on the Evaluation Context. This means the result returned can be different depending on the context, even if the DAX formula used is the same. If this is your first read on Evaluation Context, you may be wondering why it is possible to get different results when using the same DAX formula. Let\u2019s make sure we make this clear before moving on. Take a look at the below measure: Profit = SUM(Sales[SalesAmount]) - SUM(Sales[TotalCost]) What types of Evaluation Context exist? There are only two different types of Evaluation Context. The Filter Context and the Row Context . Let's take a closer look at both of them, since they form the foundation of the DAX Engine. What is the diffrence? The filter context filters data, whereas the row context iterates tables. When DAX is iterating, it is not filtering; and when it is filtering, it is not iterating","title":"Evaluation Context"},{"location":"01-KeyConcepts/01_EvaluationContext/#filter-context","text":"DAX evaluates all formulas within a respective context. Even though the formula is the same, the result is different because DAX executes the same code against different subsets of data. This context is named Filter Context and, as the name suggests, it is a context that filters tables. All DAX expressions are evaluated inside a context. The purpose of the filter context is, as its name implies, to filter tables. Filter context executes DAX code against a subset of Data Visual interactions in Power BI creates such a context","title":"Filter-Context"},{"location":"01-KeyConcepts/01_EvaluationContext/#row-context","text":"The Row-Context is not a tool to filter tables, like the Filter-Context. Instead, it is used to interate over tables and evaluate column values. Here is an example using a calculated column Sales[Gross Margin] = Sales[Quantity] * ( Sales[Net Price] - Sales[Unit Cost] ) As expected, for each row of the table there is a different value in the calculated column. Indeed, because there are given values in each row for the three columns used in the expression, it comes as a natural consequence that the fi nal expression computes different values. As it happened with the filter context, the reason is the presence of an evaluation context. This time, the context does not filter a table. Instead, it identifies the row for which the calculation happens. The row context references a row in the result of a DAX table expression Calculated columns always act in a row context A row in a report is not a row context To create a row context in a DAX-Formula use one of the X-Function like SUMX","title":"Row-Context"},{"location":"01-KeyConcepts/02_CALCULATE_CALCULATETABLE/","text":"CALCULATE and CALCULATE TABLE CALCULATE is the most important, useful, and complex function in DAX. The function itself is simple to learn, it only performs a few tasks. Complexity comes from the fact that CALCULATE and CALCULATETABLE are the only functions in DAX that can create new filter contexts. Thus, although they are simple functions, using CALCULATE or CALCULATETABLE in a formula instantly increases its complexity. How does it work? CALCULATE makes a copy of the current filter context CALCULATE evaluates each filter argument and produces, for each condition, the list of valid values for the specified columns. If two or more filter arguments affect the same column, they are merged together using an AND operator. CALCULATE uses the new condition to replace existing filters on the columns in the model. Once the new filter context is ready, CALCULATE applies the filter context to the model, and it computes the first argument: the expression. In the end, CALCULATE restores the original filter context, returning the computed result CALCULATE accepts fi lters of two types: Lists of values, in the form of a table expression. In that case, you provide the exact list of values you want to make visible in the new filter context. The filter can be a table with any number of columns. Only the existing combinations of values in different columns will be considered in the filter. Boolean conditions, such as Product[Color] = \u201cWhite\u201d. These filters need to work on a single column because the result needs to be a list of values for a single column. This type of filter argument is also known as predicate. Evaluation order of Calculate Whenever you look at DAX code, the natural order of evaluation is innermost fi rst. For example, look at the following expression: Sales Amount Large := SUMX ( FILTER ( Sales, Sales[Quantity] >= 100 ), Sales[Quantity] * Sales[Net Price] ) DAX needs to evaluate the result of FILTER before starting the evaluation of SUMX. In fact, SUMX iterates a table. Because that table is the result of FILTER, SUMX cannot start executing before FILTER has finished its job. This rule is true for all DAX functions, except for CALCULATE and CALCULATETABLE . Moreover, things are a bit more intricate because CALCULATE changes the fi lter context. All the fi lter arguments are executed in the fi lter context outside of CALCULATE, and each fi lter is evaluated independently. The order of filters within the same CALCULATE does not matter. Consequently, all the following measures are completely equivalent: Sales Red Contoso := CALCULATE ( [Sales Amount], 'Product'[Color] = \"Red\", KEEPFILTERS ( 'Product'[Brand] = \"Contoso\" ) ) Sales Red Contoso := CALCULATE ( [Sales Amount], KEEPFILTERS ( 'Product'[Brand] = \"Contoso\" ), 'Product'[Color] = \"Red\" ) Sales Red Contoso := VAR ColorRed = FILTER ( ALL ( 'Product'[Color] ), 'Product'[Color] = \"Red\" ) VAR BrandContoso = FILTER ( ALL ( 'Product'[Brand] ), 'Product'[Brand] = \"Contoso\" ) To make the nested measure call more evident, we can expand Sales Green this way: Green calling Red Exp := CALCULATE ( CALCULATE ( [Sales Amount], 'Product'[Color] = \"Red\" ), 'Product'[Color] = \"Green\" ) First, the outer CALCULATE applies the fi lter, Product[Color] = \u201cGreen\u201d Second, the inner CALCULATE applies the fi lter, Product[Color] = \u201cRed\u201d. This fi lter overwrites the previous filter. Last, DAX computes [Sales Amount] with a filter for Product[Color] = \u201cRed\u201d","title":"CALCULATE and CALCULATE TABLE"},{"location":"01-KeyConcepts/02_CALCULATE_CALCULATETABLE/#calculate-and-calculate-table","text":"CALCULATE is the most important, useful, and complex function in DAX. The function itself is simple to learn, it only performs a few tasks. Complexity comes from the fact that CALCULATE and CALCULATETABLE are the only functions in DAX that can create new filter contexts. Thus, although they are simple functions, using CALCULATE or CALCULATETABLE in a formula instantly increases its complexity.","title":"CALCULATE and CALCULATE TABLE"},{"location":"01-KeyConcepts/02_CALCULATE_CALCULATETABLE/#how-does-it-work","text":"CALCULATE makes a copy of the current filter context CALCULATE evaluates each filter argument and produces, for each condition, the list of valid values for the specified columns. If two or more filter arguments affect the same column, they are merged together using an AND operator. CALCULATE uses the new condition to replace existing filters on the columns in the model. Once the new filter context is ready, CALCULATE applies the filter context to the model, and it computes the first argument: the expression. In the end, CALCULATE restores the original filter context, returning the computed result CALCULATE accepts fi lters of two types: Lists of values, in the form of a table expression. In that case, you provide the exact list of values you want to make visible in the new filter context. The filter can be a table with any number of columns. Only the existing combinations of values in different columns will be considered in the filter. Boolean conditions, such as Product[Color] = \u201cWhite\u201d. These filters need to work on a single column because the result needs to be a list of values for a single column. This type of filter argument is also known as predicate.","title":"How does it work?"},{"location":"01-KeyConcepts/02_CALCULATE_CALCULATETABLE/#evaluation-order-of-calculate","text":"Whenever you look at DAX code, the natural order of evaluation is innermost fi rst. For example, look at the following expression: Sales Amount Large := SUMX ( FILTER ( Sales, Sales[Quantity] >= 100 ), Sales[Quantity] * Sales[Net Price] ) DAX needs to evaluate the result of FILTER before starting the evaluation of SUMX. In fact, SUMX iterates a table. Because that table is the result of FILTER, SUMX cannot start executing before FILTER has finished its job. This rule is true for all DAX functions, except for CALCULATE and CALCULATETABLE . Moreover, things are a bit more intricate because CALCULATE changes the fi lter context. All the fi lter arguments are executed in the fi lter context outside of CALCULATE, and each fi lter is evaluated independently. The order of filters within the same CALCULATE does not matter. Consequently, all the following measures are completely equivalent: Sales Red Contoso := CALCULATE ( [Sales Amount], 'Product'[Color] = \"Red\", KEEPFILTERS ( 'Product'[Brand] = \"Contoso\" ) ) Sales Red Contoso := CALCULATE ( [Sales Amount], KEEPFILTERS ( 'Product'[Brand] = \"Contoso\" ), 'Product'[Color] = \"Red\" ) Sales Red Contoso := VAR ColorRed = FILTER ( ALL ( 'Product'[Color] ), 'Product'[Color] = \"Red\" ) VAR BrandContoso = FILTER ( ALL ( 'Product'[Brand] ), 'Product'[Brand] = \"Contoso\" ) To make the nested measure call more evident, we can expand Sales Green this way: Green calling Red Exp := CALCULATE ( CALCULATE ( [Sales Amount], 'Product'[Color] = \"Red\" ), 'Product'[Color] = \"Green\" ) First, the outer CALCULATE applies the fi lter, Product[Color] = \u201cGreen\u201d Second, the inner CALCULATE applies the fi lter, Product[Color] = \u201cRed\u201d. This fi lter overwrites the previous filter. Last, DAX computes [Sales Amount] with a filter for Product[Color] = \u201cRed\u201d","title":"Evaluation order of Calculate"},{"location":"01-KeyConcepts/03_ContextTransition/","text":"Context Transition Context transition creates a Filter-Context out of a Row-Context During an iteration, CALCULATE adds a filter argument for each of the columns of the iterated table. This happens even the filter arguments are not visible. Important considerations: Context transition is expensive: For each iterated row a filter context is created It is not filtering only one row. When the row context is moved to a filter context through context transition, the newly created filter context filters all the rows with the same set of values. The filter uses columns that are not visible in the formula. All iterated columns create the context Context transition is invoked whenever there is a filter context. Have in mind that there is always a row context in calculated columns the concept can be shown most simply with a calculated column: c_Revenue_Sum = SUM(FactRevenue[mRevenue]) c_Revenue_Caclulate = CALCULATE(SUM(FactRevenue[mRevenue]))","title":"Context Transition"},{"location":"01-KeyConcepts/03_ContextTransition/#context-transition","text":"Context transition creates a Filter-Context out of a Row-Context During an iteration, CALCULATE adds a filter argument for each of the columns of the iterated table. This happens even the filter arguments are not visible. Important considerations: Context transition is expensive: For each iterated row a filter context is created It is not filtering only one row. When the row context is moved to a filter context through context transition, the newly created filter context filters all the rows with the same set of values. The filter uses columns that are not visible in the formula. All iterated columns create the context Context transition is invoked whenever there is a filter context. Have in mind that there is always a row context in calculated columns the concept can be shown most simply with a calculated column: c_Revenue_Sum = SUM(FactRevenue[mRevenue]) c_Revenue_Caclulate = CALCULATE(SUM(FactRevenue[mRevenue]))","title":"Context Transition"},{"location":"01-KeyConcepts/05_Lab/","text":"Lab 1: Key Concepts In the labs we try to apply what we have learned. Often there is not one solution, so the approach is yours to choose. Of course, in reality there are other aspects to consider, such as performance or readability of the code. But this should not be part of the training. Useful Function SUM Adds all the numbers in a column. CALCULATE Evaluates an expression in a context modified by filters. ALL Returns all the rows in a table, or all the values in a column, ignoring any filters that might have been applied. BLANK Returns a blank. FORMAT Converts a value to text in the specified number format. FILTER Returns a table that has been filtered. EARLIER Returns the value in the column prior to the specified number of table scans (default is 1). VALUES When a column name is given, returns a single column table of unique values. When a table name is given, returns a table with the same columns and all the rows of the table (including duplicates) with the additional blank row if present. SUMMARIZE Creates a summary of the input table grouped by the specified columns. CONCATENATEX Evaluates expression for each row on the table, then return the concatenation of those values in a single string result, seperated by the specified delimiter. CONTAINS Returns TRUE if there exists at least one row where all columns have specified values. IF Checks whether a condition is met, and returns one value if TRUE, and another value if FALSE. LEFT Returns the specified number of characters from the start of a text string. Exercise Calculate the profit as a Measure (SalesAmount \u2013 TotalCost) Calculate the profit as a calculated column (Sales \u2013 TotalCost \u2013 DiscountAmount) Create a calculated column in the Calender with the MonthNameShort (Jun, Aug etc.) Create a Hierarchy in the Calendar YYYYMMDD and set the right sort order per month Create a Measure that is only returning the Profit for ProductCategegory Audio Create the same Measure as in 3 but avoid returning a value if no profit for a ProductCategory exists Show the ratio of profit per product categegory to total profit Create a calculated column that is showing accumulated profit per Day (All profit <= Date) Create a measure that is displaying the selected time range (if one selected Jun 2021 if two ore more Jun 2021 \u2013 Sep 2021)","title":"Lab 1: Key Concepts"},{"location":"01-KeyConcepts/05_Lab/#lab-1-key-concepts","text":"In the labs we try to apply what we have learned. Often there is not one solution, so the approach is yours to choose. Of course, in reality there are other aspects to consider, such as performance or readability of the code. But this should not be part of the training.","title":"Lab 1: Key Concepts"},{"location":"01-KeyConcepts/05_Lab/#useful-function","text":"SUM Adds all the numbers in a column. CALCULATE Evaluates an expression in a context modified by filters. ALL Returns all the rows in a table, or all the values in a column, ignoring any filters that might have been applied. BLANK Returns a blank. FORMAT Converts a value to text in the specified number format. FILTER Returns a table that has been filtered. EARLIER Returns the value in the column prior to the specified number of table scans (default is 1). VALUES When a column name is given, returns a single column table of unique values. When a table name is given, returns a table with the same columns and all the rows of the table (including duplicates) with the additional blank row if present. SUMMARIZE Creates a summary of the input table grouped by the specified columns. CONCATENATEX Evaluates expression for each row on the table, then return the concatenation of those values in a single string result, seperated by the specified delimiter. CONTAINS Returns TRUE if there exists at least one row where all columns have specified values. IF Checks whether a condition is met, and returns one value if TRUE, and another value if FALSE. LEFT Returns the specified number of characters from the start of a text string.","title":"Useful Function"},{"location":"01-KeyConcepts/05_Lab/#exercise","text":"Calculate the profit as a Measure (SalesAmount \u2013 TotalCost) Calculate the profit as a calculated column (Sales \u2013 TotalCost \u2013 DiscountAmount) Create a calculated column in the Calender with the MonthNameShort (Jun, Aug etc.) Create a Hierarchy in the Calendar YYYYMMDD and set the right sort order per month Create a Measure that is only returning the Profit for ProductCategegory Audio Create the same Measure as in 3 but avoid returning a value if no profit for a ProductCategory exists Show the ratio of profit per product categegory to total profit Create a calculated column that is showing accumulated profit per Day (All profit <= Date) Create a measure that is displaying the selected time range (if one selected Jun 2021 if two ore more Jun 2021 \u2013 Sep 2021)","title":"Exercise"},{"location":"01-KeyConcepts/06_Solution/","text":"Lab 1: Solution Calculate the profit as a Measure (SalesAmount \u2013 TotalCost) Profit = SUM(Sales[SalesAmount]) - SUM(Sales[TotalCost]) Calculate the profit as a calculated column (Sales \u2013 TotalCost \u2013 DiscountAmount) cProfit = CALCULATE(SUM(Sales[SalesAmount]) - SUM(Sales[TotalCost])) Create a calculated column in the Calender with the MonthNameShort (Jun, Aug etc.) MonthNameShort = FORMAT('Calendar'[DateKey], \"MMM\") Create a Hierarchy in the Calendar YYYYMMDD and set the right sort order per month Create a Measure that is only returning the Profit for ProductCategegory Audio ProfitAudio = CALCULATE ( [Profit], ProductCategory[ProductCategory] = \"Audio\" ) Create the same Measure as in 3 but avoid returning a value if no profit for a ProductCategory exists ProfitAudioCleaned = VAR varProfit = [Profit] RETURN IF ( varProfit <> 0, CALCULATE ( [Profit], ProductCategory[ProductCategory] = \"Audio\" ), BLANK () ) Show the ratio of profit per product categegory to total profit ProfitRatio = VAR varProfitCategory = [Profit] VAR varTotalProfit = CALCULATE ( [Profit], ALLSELECTED ( ProductCategory[ProductCategory] ) ) RETURN DIVIDE ( varProfitCategory, varTotalProfit ) Create a calculated column that is showing accumulated profit per Day (All profit <= Date) cProiftAcc = CALCULATE ( [Profit], FILTER ( Sales, Sales[DateKey] <= EARLIER ( Sales[DateKey] ) ) ) Create a measure that is displaying the selected time range (if one selected Jun 2021 if two ore more Jun 2021 \u2013 Sep 2021) DisplayRange = var SelectedPeriodKeys = VALUES('Calendar'[MonthOfYear]) var PeriodNames = SUMMARIZE('Calendar', 'Calendar'[MonthOfYear], 'Calendar'[MonthNameShort], 'Calendar'[YearName]) var Result = CONCATENATEX(PeriodNames, var CurrentPeriodKey = 'Calendar'[MonthOfYear] var CurrentPeriodName = 'Calendar'[MonthNameShort] var CurrentCalendarYearName = 'Calendar'[YearName] var isPrevSelected = CONTAINS(SelectedPeriodKeys,'Calendar'[MonthOfYear], CurrentPeriodKey - 1) var isNextSelected = CONTAINS(SelectedPeriodKeys,'Calendar'[MonthOfYear], CurrentPeriodKey + 1) Return if ( Not (isNextSelected && isPrevSelected), CurrentPeriodName & \" \" & CurrentCalendarYearName & if(isNextSelected, \"-\", \", \") ), \"\", 'Calendar'[MonthOfYear] ) Return LEFT(Result, LEN(Result) - 2)","title":"Lab 1: Solution"},{"location":"01-KeyConcepts/06_Solution/#lab-1-solution","text":"Calculate the profit as a Measure (SalesAmount \u2013 TotalCost) Profit = SUM(Sales[SalesAmount]) - SUM(Sales[TotalCost]) Calculate the profit as a calculated column (Sales \u2013 TotalCost \u2013 DiscountAmount) cProfit = CALCULATE(SUM(Sales[SalesAmount]) - SUM(Sales[TotalCost])) Create a calculated column in the Calender with the MonthNameShort (Jun, Aug etc.) MonthNameShort = FORMAT('Calendar'[DateKey], \"MMM\") Create a Hierarchy in the Calendar YYYYMMDD and set the right sort order per month Create a Measure that is only returning the Profit for ProductCategegory Audio ProfitAudio = CALCULATE ( [Profit], ProductCategory[ProductCategory] = \"Audio\" ) Create the same Measure as in 3 but avoid returning a value if no profit for a ProductCategory exists ProfitAudioCleaned = VAR varProfit = [Profit] RETURN IF ( varProfit <> 0, CALCULATE ( [Profit], ProductCategory[ProductCategory] = \"Audio\" ), BLANK () ) Show the ratio of profit per product categegory to total profit ProfitRatio = VAR varProfitCategory = [Profit] VAR varTotalProfit = CALCULATE ( [Profit], ALLSELECTED ( ProductCategory[ProductCategory] ) ) RETURN DIVIDE ( varProfitCategory, varTotalProfit ) Create a calculated column that is showing accumulated profit per Day (All profit <= Date) cProiftAcc = CALCULATE ( [Profit], FILTER ( Sales, Sales[DateKey] <= EARLIER ( Sales[DateKey] ) ) ) Create a measure that is displaying the selected time range (if one selected Jun 2021 if two ore more Jun 2021 \u2013 Sep 2021) DisplayRange = var SelectedPeriodKeys = VALUES('Calendar'[MonthOfYear]) var PeriodNames = SUMMARIZE('Calendar', 'Calendar'[MonthOfYear], 'Calendar'[MonthNameShort], 'Calendar'[YearName]) var Result = CONCATENATEX(PeriodNames, var CurrentPeriodKey = 'Calendar'[MonthOfYear] var CurrentPeriodName = 'Calendar'[MonthNameShort] var CurrentCalendarYearName = 'Calendar'[YearName] var isPrevSelected = CONTAINS(SelectedPeriodKeys,'Calendar'[MonthOfYear], CurrentPeriodKey - 1) var isNextSelected = CONTAINS(SelectedPeriodKeys,'Calendar'[MonthOfYear], CurrentPeriodKey + 1) Return if ( Not (isNextSelected && isPrevSelected), CurrentPeriodName & \" \" & CurrentCalendarYearName & if(isNextSelected, \"-\", \", \") ), \"\", 'Calendar'[MonthOfYear] ) Return LEFT(Result, LEN(Result) - 2)","title":"Lab 1: Solution"},{"location":"02-AdvancedConcepts/01_ExpandedTable/","text":"Expanded Table Definition In DAX, every table has a matching expanded version. The expanded version of a table contains all the columns of the original table, plus all the columns of the tables that are on the one-side of a chain of many-to-one relationships starting from the source table. Table expansion goes towards the one-side . Therefore, to expand a table, one starts from the base table and adds to the base table all the columns of the related tables that are on the one-side of any relationships. An expanded table is created by joining the columns of two tables into a larger table using a FULL OUTER JOIN. However, regular many-to-one relationships use the usual LEFT OUTER JOIN. Table expansion has nothing to do with bidirectional filtering. Expansion always happens to the 1-side of a relationship. If you activate the bidirectional cross-filter on a relationship, you are not relying on table expansion. Instead, the engine pushes certain filtering conditions in the code in order to apply the filters on both sides. Thus, in the previous model, if you enable bidirectional cross-filter on the relationship between Sales and Product, this will not add the columns of the Sales table to the expanded Product table. What you need to keep in mind RELEATED and USERELATIONSHIP Both function help you to access the expanded table RELATED = Requires a ROW-Context USERELATIONSHIP = Acts in Filter-Conter table expansion occurs when the table is defined Whenever you create or address a table in your data model. The table expansion is happening when you define atable. There is a huge difference between filtering a table vs a column Using table filters is always challenging because of table expansion. Whenever one applies a filter to a table, the filter is really applied to the expanded table, and this can cause several side effects. The golden rule is simple: Try to avoid using table filters whenever possible. Working with columns leads to simpler calculations, whereas working with tables is much more problematic. Example potential problems Example 1 Trying to add the calculated column Sales[DeliveryQuarter] to figuer out whether the delivery happened in the same quarter as the order. There are several problems here. The first is that CALCULATE removes the row context, but CALCLATE is needed to change the active relationship for RELATED. Thus, RELATED cannot be used inside the formula argument of CALCULATE because RELATED requires a row context. There is a second sneaky problem: Even if it were possible to do that, RELATED would not work because the row context of a calculated column is created when the table is defi ned. The row context of a calculated column is generated automatically, so the table is always expanded using the default relationship. Example 2 Filter arguments of CALCULATE iterates over sales and returns all Sales with a value <1. As you always reference the expanded table. Therefore you include the entire product table. The filter arguments of CALCULATE are evaluated in the original filter context, ignoring the context transition. The filter on Brand comes into effect after CALCULATE has performed the context transition -> All Brands included Conculsion Table expansion is a unique concept introduced in DAX, which incorporates the notion of relationships. Though it seems strange in the beginning, it becomes very natural once you get used to it.","title":"Expanded Table"},{"location":"02-AdvancedConcepts/01_ExpandedTable/#expanded-table","text":"","title":"Expanded Table"},{"location":"02-AdvancedConcepts/01_ExpandedTable/#definition","text":"In DAX, every table has a matching expanded version. The expanded version of a table contains all the columns of the original table, plus all the columns of the tables that are on the one-side of a chain of many-to-one relationships starting from the source table. Table expansion goes towards the one-side . Therefore, to expand a table, one starts from the base table and adds to the base table all the columns of the related tables that are on the one-side of any relationships. An expanded table is created by joining the columns of two tables into a larger table using a FULL OUTER JOIN. However, regular many-to-one relationships use the usual LEFT OUTER JOIN. Table expansion has nothing to do with bidirectional filtering. Expansion always happens to the 1-side of a relationship. If you activate the bidirectional cross-filter on a relationship, you are not relying on table expansion. Instead, the engine pushes certain filtering conditions in the code in order to apply the filters on both sides. Thus, in the previous model, if you enable bidirectional cross-filter on the relationship between Sales and Product, this will not add the columns of the Sales table to the expanded Product table.","title":"Definition"},{"location":"02-AdvancedConcepts/01_ExpandedTable/#what-you-need-to-keep-in-mind","text":"RELEATED and USERELATIONSHIP Both function help you to access the expanded table RELATED = Requires a ROW-Context USERELATIONSHIP = Acts in Filter-Conter table expansion occurs when the table is defined Whenever you create or address a table in your data model. The table expansion is happening when you define atable. There is a huge difference between filtering a table vs a column Using table filters is always challenging because of table expansion. Whenever one applies a filter to a table, the filter is really applied to the expanded table, and this can cause several side effects. The golden rule is simple: Try to avoid using table filters whenever possible. Working with columns leads to simpler calculations, whereas working with tables is much more problematic.","title":"What you need to keep in mind"},{"location":"02-AdvancedConcepts/01_ExpandedTable/#example-potential-problems","text":"Example 1 Trying to add the calculated column Sales[DeliveryQuarter] to figuer out whether the delivery happened in the same quarter as the order. There are several problems here. The first is that CALCULATE removes the row context, but CALCLATE is needed to change the active relationship for RELATED. Thus, RELATED cannot be used inside the formula argument of CALCULATE because RELATED requires a row context. There is a second sneaky problem: Even if it were possible to do that, RELATED would not work because the row context of a calculated column is created when the table is defi ned. The row context of a calculated column is generated automatically, so the table is always expanded using the default relationship. Example 2 Filter arguments of CALCULATE iterates over sales and returns all Sales with a value <1. As you always reference the expanded table. Therefore you include the entire product table. The filter arguments of CALCULATE are evaluated in the original filter context, ignoring the context transition. The filter on Brand comes into effect after CALCULATE has performed the context transition -> All Brands included","title":"Example potential problems"},{"location":"02-AdvancedConcepts/01_ExpandedTable/#conculsion","text":"Table expansion is a unique concept introduced in DAX, which incorporates the notion of relationships. Though it seems strange in the beginning, it becomes very natural once you get used to it.","title":"Conculsion"},{"location":"02-AdvancedConcepts/02_Relationships/","text":"Relationships In tabular models, a relationship is a connection between two tables of data. The relationship establishes how the data in the two tables should be correlated. Pyhsical Relationships Relationships are applied and defined in the data model. Regular = the engine knows that the one-side of the relationship contains unique values Limitied = the enginge can not ensure uniqueness or due to technical reasons (Type and Cross filter Direction) -> No Table Expansion Types = one-to-many (SMR), one-to-one (SSR), many-to-many (MMR) Cross-Filter = Direction used by the filter context. Single (one direction), Both (both direction) Inactive = Only one Active Relationship on column allowed. USERELATIONSHIPS USERELATIONSHIPS to apply inactive. Virtual Relationship A virtual relationship is a filter applied to the filter context Performance is slower compared to physical relationships They can be achieved by different DAX functions IN The IN operator returns TRUE if a row of values exists or contained in a table, otherwise returns FALSE. Except syntax, the IN operator and CONTAINSROW function are functionally equivalent, as in the following example. TREATAS Treats the columns of the input table as columns from other tables.For each column, filters out any values that are not present in its respective output column. INTERSECT Returns the rows of left-side table which appear in right-side table. CONTAINS Returns TRUE if there exists at least one row where all columns have specified values. There are more functions that enables you to traverse a filter to a table. This ist just a short overview. Requirements for relationships Single Active Relationship between tables One relationship for each source column Unique identifier for each table (primary Key) Unique lookup columns (The data values in the lookup column must be unique) Compatible data types Composite keys and lookup columns (You cannot use composite keys in a tabular model; you must always have one column that uniquely identifies each row in the table) Choosing the right type of relationship A physical relationship is defined in the data model; a virtual relationship only exists in DAX code. A physical relationship defines a constraint on the one-side table of the relationship. A physical relationship is faster than a virtual relationship. Performance Priority should be Physical one-to-many relationships to get best performance and the best use of the VertiPaq engine. Calculated physical relationships have the same query performance as relationships on native columns. Bidirectional cross-filter relationships, many-to-many with table expansion, and weak relationships are a second option. They provide good performance and a good use of the engine, although not the best. Virtual relationships are the last choice because of the risk of bad performance.","title":"Relationships"},{"location":"02-AdvancedConcepts/02_Relationships/#relationships","text":"In tabular models, a relationship is a connection between two tables of data. The relationship establishes how the data in the two tables should be correlated.","title":"Relationships"},{"location":"02-AdvancedConcepts/02_Relationships/#pyhsical-relationships","text":"Relationships are applied and defined in the data model. Regular = the engine knows that the one-side of the relationship contains unique values Limitied = the enginge can not ensure uniqueness or due to technical reasons (Type and Cross filter Direction) -> No Table Expansion Types = one-to-many (SMR), one-to-one (SSR), many-to-many (MMR) Cross-Filter = Direction used by the filter context. Single (one direction), Both (both direction) Inactive = Only one Active Relationship on column allowed. USERELATIONSHIPS USERELATIONSHIPS to apply inactive.","title":"Pyhsical Relationships"},{"location":"02-AdvancedConcepts/02_Relationships/#virtual-relationship","text":"A virtual relationship is a filter applied to the filter context Performance is slower compared to physical relationships They can be achieved by different DAX functions IN The IN operator returns TRUE if a row of values exists or contained in a table, otherwise returns FALSE. Except syntax, the IN operator and CONTAINSROW function are functionally equivalent, as in the following example. TREATAS Treats the columns of the input table as columns from other tables.For each column, filters out any values that are not present in its respective output column. INTERSECT Returns the rows of left-side table which appear in right-side table. CONTAINS Returns TRUE if there exists at least one row where all columns have specified values. There are more functions that enables you to traverse a filter to a table. This ist just a short overview.","title":"Virtual Relationship"},{"location":"02-AdvancedConcepts/02_Relationships/#requirements-for-relationships","text":"Single Active Relationship between tables One relationship for each source column Unique identifier for each table (primary Key) Unique lookup columns (The data values in the lookup column must be unique) Compatible data types Composite keys and lookup columns (You cannot use composite keys in a tabular model; you must always have one column that uniquely identifies each row in the table)","title":"Requirements for relationships"},{"location":"02-AdvancedConcepts/02_Relationships/#choosing-the-right-type-of-relationship","text":"A physical relationship is defined in the data model; a virtual relationship only exists in DAX code. A physical relationship defines a constraint on the one-side table of the relationship. A physical relationship is faster than a virtual relationship.","title":"Choosing the right type of relationship"},{"location":"02-AdvancedConcepts/02_Relationships/#performance-priority-should-be","text":"Physical one-to-many relationships to get best performance and the best use of the VertiPaq engine. Calculated physical relationships have the same query performance as relationships on native columns. Bidirectional cross-filter relationships, many-to-many with table expansion, and weak relationships are a second option. They provide good performance and a good use of the engine, although not the best. Virtual relationships are the last choice because of the risk of bad performance.","title":"Performance Priority should be"},{"location":"02-AdvancedConcepts/03_DataLineage/","text":"Data Lineage Data lineage is a tag. Assigned to every column in a table, this tag identifies the original column in the data model that the values of a column originated from For a value to filter the model, DAX needs to know the data lineage of the value itself. A value that represents a column in the data model holds the data lineage of that column. On the other hand, a value that is not linked to any column in the data model is an anonymous value. Usually, DAX handles all the complexity but in cases you need to maintain, changing or creating the lineage, it is important to know how it works. Manipulating data lineage TREATAS Treats the columns of the input table as columns from other tables.For each column, filters out any values that are not present in its respective output column. SimpleTreatas = CALCULATE ( [Sales Amount], TREATAS({ \"Red\", \"Blue\" }, 'Product'[Color]) ) A simple column reference maintains its data lineage, whereas an expression is always anonymous. ADDCOLUMNS ( VALUES( 'Product'[Color]), \"Color without lineage\", 'Product'[Color] & \"\" )","title":"Data Lineage"},{"location":"02-AdvancedConcepts/03_DataLineage/#data-lineage","text":"Data lineage is a tag. Assigned to every column in a table, this tag identifies the original column in the data model that the values of a column originated from For a value to filter the model, DAX needs to know the data lineage of the value itself. A value that represents a column in the data model holds the data lineage of that column. On the other hand, a value that is not linked to any column in the data model is an anonymous value. Usually, DAX handles all the complexity but in cases you need to maintain, changing or creating the lineage, it is important to know how it works.","title":"Data Lineage"},{"location":"02-AdvancedConcepts/03_DataLineage/#manipulating-data-lineage","text":"TREATAS Treats the columns of the input table as columns from other tables.For each column, filters out any values that are not present in its respective output column. SimpleTreatas = CALCULATE ( [Sales Amount], TREATAS({ \"Red\", \"Blue\" }, 'Product'[Color]) ) A simple column reference maintains its data lineage, whereas an expression is always anonymous. ADDCOLUMNS ( VALUES( 'Product'[Color]), \"Color without lineage\", 'Product'[Color] & \"\" )","title":"Manipulating data lineage"},{"location":"02-AdvancedConcepts/04_VirturalTables/","text":"Virtual Tables CALCULATE filter arguments are tables. When authoring complex formulas, an ability to build the correct filter table is of paramount importance. CALCULATETABLE Evaluates a table expression in a context modified by filters. EVALUATE CALCULATETABLE ( Geography, Geography[ContinentName] = \"Europe\" ) ADDCOLUMNS Returns a table with new columns specified by the DAX expressions. EVALUATE ADDCOLUMNS ( VALUES ( Geography[ContinentName] ), \"@Profit\", [Profit] ) SUMMARIZE Creates a summary of the input table grouped by the specified columns. EVALUATE SUMMARIZE(Sales, Stores[StoreName], Geography[ContinentName]) SUMMARIZECOLUMNS Create a summary table for the requested totals over set of groups. EVALUATE SUMMARIZECOLUMNS ( Stores[StoreName], Geography[ContinentName], \"@Profit\", [Profit] ) CROSSJOIN Returns a table that is a crossjoin of the specified tables. EVALUATE CROSSJOIN ( VALUES ( Stores[StoreName] ), VALUES ( Geography[ContinentName] ) ) UNION Returns the union of the tables whose columns match. EVALUATE Union ( VALUES ( Stores[StoreName] ), VALUES ( Geography[ContinentName] ) ) INTERSECT Returns the rows of left-side table which appear in right-side table. DEFINE VAR tbl_Stores = VALUES ( Stores[StoreName] ) VAR tbl_Filter = { \"Contoso Redmond Store\", \"Contoso Sunnyside Store\" } EVALUATE INTERSECT ( tbl_Stores, tbl_Filter ) EXCEPT Returns the rows of left-side table which do not appear in right-side table. DEFINE VAR tbl_Stores = VALUES ( Stores[StoreName] ) VAR tbl_Filter = { \"Contoso Redmond Store\", \"Contoso Sunnyside Store\" } VAR tbl_ExceptStores = FILTER ( tbl_stores, NOT Stores[StoreName] IN ( tbl_Filter ) ) EVALUATE EXCEPT ( tbl_Stores, tbl_ExceptStores ) SELECTCOLUMNS Returns a table with selected columns from the table and new columns specified by the DAX expressions. EVALUATE DISTINCT ( SELECTCOLUMNS ( 'Calendar', \"Jahr\", 'Calendar'[YearName], \"Monat\", 'Calendar'[MonthName] ) ) DATATABLE Returns a table with data defined inline. EVALUATE DATATABLE ( \"Name\", STRING, \"ID\", INTEGER, { { \"Small\", 1 }, { \"Medium\", 2 }, { \"Large\", 3 } } ) ORDER BY [ID] GENERATESERIES Returns a table with one column, populated with sequential values from start to end. EVALUATE GENERATESERIES ( 1, 3, 0.5 ) NATURALINNERJOIN Joins the Left table with right table using the Inner Join semantics. DEFINE VAR tbl_Stores = VALUES ( Stores[StoreName] ) VAR tbl_Filter = DATATABLE ( \"Stores[StoreName]\", STRING, { { \"Contoso Redmond Store\" }, { \"Contoso Sunnyside Store\" } } ) EVALUATE NATURALINNERJOIN ( tbl_Stores, TREATAS ( tbl_Filter, Stores[StoreName] ) ) NATURALLEFTOUTERJOIN Joins the Left table with right table using the Left Outer Join semantics. DEFINE VAR StoresByContinent = DISTINCT ( SELECTCOLUMNS ( ADDCOLUMNS ( SUMMARIZE ( Sales, Stores[StoreName], Geography[ContinentName] ), \"@CountStores\", CALCULATE ( COUNTROWS ( Stores ), REMOVEFILTERS ( Stores[StoreName] ) ) ), \"Geography[ContinentName]\", Geography[ContinentName], \"@CountStores\", [@CountStores] ) ) VAR ProfitByContinten = SUMMARIZECOLUMNS ( Geography[ContinentName], \"@Profit\", [Profit] ) EVALUATE NATURALLEFTOUTERJOIN(storesByContinent, ProfitByContinten) GENERATE The second table expression will be evaluated for each row in the first table. Returns the crossjoin of the first table with these results. DEFINE VAR BaseCalendar = CALENDAR ( DATE ( 2021, 1, 1 ), DATE ( 2021, 1, 3 ) ) EVALUATE GENERATE ( BaseCalendar, VAR BaseDate = [Date] VAR YearDate = YEAR ( BaseDate ) VAR MonthNumber = MONTH ( BaseDate ) VAR YearMonthNumber = YearDate * 12 + MonthNumber - 1 RETURN ROW ( \"Day\", BaseDate, \"Year\", YearDate, \"Month Number\", MonthNumber, \"Month\", FORMAT ( BaseDate, \"mmmm\" ), \"Year Month Number\", YearMonthNumber, \"Year Month\", FORMAT ( BaseDate, \"mmm yy\" ) ) )","title":"Virtual Tables"},{"location":"02-AdvancedConcepts/04_VirturalTables/#virtual-tables","text":"CALCULATE filter arguments are tables. When authoring complex formulas, an ability to build the correct filter table is of paramount importance. CALCULATETABLE Evaluates a table expression in a context modified by filters. EVALUATE CALCULATETABLE ( Geography, Geography[ContinentName] = \"Europe\" ) ADDCOLUMNS Returns a table with new columns specified by the DAX expressions. EVALUATE ADDCOLUMNS ( VALUES ( Geography[ContinentName] ), \"@Profit\", [Profit] ) SUMMARIZE Creates a summary of the input table grouped by the specified columns. EVALUATE SUMMARIZE(Sales, Stores[StoreName], Geography[ContinentName]) SUMMARIZECOLUMNS Create a summary table for the requested totals over set of groups. EVALUATE SUMMARIZECOLUMNS ( Stores[StoreName], Geography[ContinentName], \"@Profit\", [Profit] ) CROSSJOIN Returns a table that is a crossjoin of the specified tables. EVALUATE CROSSJOIN ( VALUES ( Stores[StoreName] ), VALUES ( Geography[ContinentName] ) ) UNION Returns the union of the tables whose columns match. EVALUATE Union ( VALUES ( Stores[StoreName] ), VALUES ( Geography[ContinentName] ) ) INTERSECT Returns the rows of left-side table which appear in right-side table. DEFINE VAR tbl_Stores = VALUES ( Stores[StoreName] ) VAR tbl_Filter = { \"Contoso Redmond Store\", \"Contoso Sunnyside Store\" } EVALUATE INTERSECT ( tbl_Stores, tbl_Filter ) EXCEPT Returns the rows of left-side table which do not appear in right-side table. DEFINE VAR tbl_Stores = VALUES ( Stores[StoreName] ) VAR tbl_Filter = { \"Contoso Redmond Store\", \"Contoso Sunnyside Store\" } VAR tbl_ExceptStores = FILTER ( tbl_stores, NOT Stores[StoreName] IN ( tbl_Filter ) ) EVALUATE EXCEPT ( tbl_Stores, tbl_ExceptStores ) SELECTCOLUMNS Returns a table with selected columns from the table and new columns specified by the DAX expressions. EVALUATE DISTINCT ( SELECTCOLUMNS ( 'Calendar', \"Jahr\", 'Calendar'[YearName], \"Monat\", 'Calendar'[MonthName] ) ) DATATABLE Returns a table with data defined inline. EVALUATE DATATABLE ( \"Name\", STRING, \"ID\", INTEGER, { { \"Small\", 1 }, { \"Medium\", 2 }, { \"Large\", 3 } } ) ORDER BY [ID] GENERATESERIES Returns a table with one column, populated with sequential values from start to end. EVALUATE GENERATESERIES ( 1, 3, 0.5 ) NATURALINNERJOIN Joins the Left table with right table using the Inner Join semantics. DEFINE VAR tbl_Stores = VALUES ( Stores[StoreName] ) VAR tbl_Filter = DATATABLE ( \"Stores[StoreName]\", STRING, { { \"Contoso Redmond Store\" }, { \"Contoso Sunnyside Store\" } } ) EVALUATE NATURALINNERJOIN ( tbl_Stores, TREATAS ( tbl_Filter, Stores[StoreName] ) ) NATURALLEFTOUTERJOIN Joins the Left table with right table using the Left Outer Join semantics. DEFINE VAR StoresByContinent = DISTINCT ( SELECTCOLUMNS ( ADDCOLUMNS ( SUMMARIZE ( Sales, Stores[StoreName], Geography[ContinentName] ), \"@CountStores\", CALCULATE ( COUNTROWS ( Stores ), REMOVEFILTERS ( Stores[StoreName] ) ) ), \"Geography[ContinentName]\", Geography[ContinentName], \"@CountStores\", [@CountStores] ) ) VAR ProfitByContinten = SUMMARIZECOLUMNS ( Geography[ContinentName], \"@Profit\", [Profit] ) EVALUATE NATURALLEFTOUTERJOIN(storesByContinent, ProfitByContinten) GENERATE The second table expression will be evaluated for each row in the first table. Returns the crossjoin of the first table with these results. DEFINE VAR BaseCalendar = CALENDAR ( DATE ( 2021, 1, 1 ), DATE ( 2021, 1, 3 ) ) EVALUATE GENERATE ( BaseCalendar, VAR BaseDate = [Date] VAR YearDate = YEAR ( BaseDate ) VAR MonthNumber = MONTH ( BaseDate ) VAR YearMonthNumber = YearDate * 12 + MonthNumber - 1 RETURN ROW ( \"Day\", BaseDate, \"Year\", YearDate, \"Month Number\", MonthNumber, \"Month\", FORMAT ( BaseDate, \"mmmm\" ), \"Year Month Number\", YearMonthNumber, \"Year Month\", FORMAT ( BaseDate, \"mmm yy\" ) ) )","title":"Virtual Tables"},{"location":"02-AdvancedConcepts/05_SpecialFilterContext/","text":"Special Filter context Shadow Filter context: ALLSELECTED is the only function shadow filter context and thus may makes it the most complex formula of all in terms of technical implementation. Usually, you can think of the function, as it would pick all the filter coming from outside of a visual. But a DAX-Query is actually not aware of any current visual. When used as a table function, ALLSELECTED returns the set of values as visible in the last shadow filter context. When used as a CALCULATE modifier, ALLSELECTED restores the last shadow filter context on its parameter.The details and technical function is beyond the scope of that training. Aut Exists: Auto-exist is a technology built into DAX with the simple goal of avoiding useless calculations. Arbitrarly shaped filter: Filters in the filter context can have two different shapes: simple filters and arbitrarily shaped filters. Arbitrarily shaped filters can be created by using a PivotTable in Excel, DAX Code or hierarchical slicers. Arbitrarily shaped filters are complex to use in DAX because of the way CALCULATE might change them in the filter context.","title":"Special Filter context"},{"location":"02-AdvancedConcepts/05_SpecialFilterContext/#special-filter-context","text":"","title":"Special Filter context"},{"location":"02-AdvancedConcepts/05_SpecialFilterContext/#shadow-filter-context","text":"ALLSELECTED is the only function shadow filter context and thus may makes it the most complex formula of all in terms of technical implementation. Usually, you can think of the function, as it would pick all the filter coming from outside of a visual. But a DAX-Query is actually not aware of any current visual. When used as a table function, ALLSELECTED returns the set of values as visible in the last shadow filter context. When used as a CALCULATE modifier, ALLSELECTED restores the last shadow filter context on its parameter.The details and technical function is beyond the scope of that training.","title":"Shadow Filter context:"},{"location":"02-AdvancedConcepts/05_SpecialFilterContext/#aut-exists","text":"Auto-exist is a technology built into DAX with the simple goal of avoiding useless calculations.","title":"Aut Exists:"},{"location":"02-AdvancedConcepts/05_SpecialFilterContext/#arbitrarly-shaped-filter","text":"Filters in the filter context can have two different shapes: simple filters and arbitrarily shaped filters. Arbitrarily shaped filters can be created by using a PivotTable in Excel, DAX Code or hierarchical slicers. Arbitrarily shaped filters are complex to use in DAX because of the way CALCULATE might change them in the filter context.","title":"Arbitrarly shaped filter:"},{"location":"02-AdvancedConcepts/06_Lab/","text":"Lab Advanced Concepts Query the following table expression in DAX studio: Return the entire Calendar Create a table with Product Category, Product Subcategory, Sales Year, and total Sales Amount Create a table that includes Year and Date from calendar for the year 2006 Create a table that contains all Products with Profit for year 2005, the Average Sales Quantity per Order for June 2011 and the profit margin for alle years (Revenue - Cost) / Revenue Create a custom table with RegionCountryName (United States and Germany as Values) and City (Custom cities). Use the custom table from exercice 5 to filter the Geography table and return only the continents that are filtered by your Countries Use a FILTER operation Use a Join operation Create a custom table SpecialDiscount with two Rows StartDate (DATETIME) 1/1/2013 And EndDate (DATETIME) 1/6/2013 AM And Discount (DOUBLE) 0.10 StartDate (DATETIME) 1/6/2013 And EndDate (DATETIME) 31/12/2013 And Discount (DOUBLE) 0.30 StartDate (DATETIME) 1/6/2013 And EndDate (DATETIME) 31/12/2013 And Discount (DOUBLE) 0.30 Calculate a table that gives any order a special discount, that has not already got a discount via a promotion","title":"Lab Advanced Concepts"},{"location":"02-AdvancedConcepts/06_Lab/#lab-advanced-concepts","text":"Query the following table expression in DAX studio: Return the entire Calendar Create a table with Product Category, Product Subcategory, Sales Year, and total Sales Amount Create a table that includes Year and Date from calendar for the year 2006 Create a table that contains all Products with Profit for year 2005, the Average Sales Quantity per Order for June 2011 and the profit margin for alle years (Revenue - Cost) / Revenue Create a custom table with RegionCountryName (United States and Germany as Values) and City (Custom cities). Use the custom table from exercice 5 to filter the Geography table and return only the continents that are filtered by your Countries Use a FILTER operation Use a Join operation Create a custom table SpecialDiscount with two Rows StartDate (DATETIME) 1/1/2013 And EndDate (DATETIME) 1/6/2013 AM And Discount (DOUBLE) 0.10 StartDate (DATETIME) 1/6/2013 And EndDate (DATETIME) 31/12/2013 And Discount (DOUBLE) 0.30 StartDate (DATETIME) 1/6/2013 And EndDate (DATETIME) 31/12/2013 And Discount (DOUBLE) 0.30 Calculate a table that gives any order a special discount, that has not already got a discount via a promotion","title":"Lab Advanced Concepts"},{"location":"02-AdvancedConcepts/07_Solution/","text":"Lab Solution Query the following table expression in DAX studio agains the Contos PowerBI model: Return the entire Calendar EVALUATE 'Calendar' Create a table with Product Category, Product Subcategory, Sales Year, and total Sales Amount EVALUATE SUMMARIZECOLUMNS ( ProductCategory[ProductCategory], ProductSubcategory[ProductSubcategory], 'Calendar'[YearName], \"Profit\", [Profit] ) Create a table that includes Year and Date from calendar for the year 2006 // Option A: Use FILTER EVALUATE FILTER ( SELECTCOLUMNS ( 'Calendar', \"@Date\", 'Calendar'[Date], \"@Year\", 'Calendar'[YearName] ), [@Year] = \"2006\" ) // Option B: Use CALCULATETABLE EVALUATE CALCULATETABLE( SELECTCOLUMNS ( 'Calendar', \"@Date\", 'Calendar'[Date], \"@Year\", 'Calendar'[YearName] ), 'Calendar'[Year] = 2006 ) Create a table that contains all Products with Profit for year 2005, the Average Sales Quantity per Order for June 2011 and the profit margin for alle years (Sales - Cost) / Sales EVALUATE ADDCOLUMNS ( VALUES ( ProductCategory ), \"Profit2006\", FORMAT ( CALCULATE ( [Profit], 'Calendar'[Year] = 2011 ), \"\"\"US$\"\" #,0.00\" ), \"AvgSalesLast30Days\", CALCULATE ( AVERAGE ( Sales[SalesQuantity] ), 'Calendar'[Year] = 2011, 'Calendar'[MonthName] = \"July\" ), \"ProfitMargin\", FORMAT ( DIVIDE ( [Profit], SUM ( sales[SalesAmount] ) ), \"Percent\" )) Create a custom table with RegionCountryName (United States and Germany as Values) and City (Custom cities). EVALUATE DATATABLE ( \"RegionCountryName\", STRING, \"City\", STRING, { { \"United States\", \"New York\" }, { \"United States\", \"Los Angeles\" }, { \"United States\", \"Miami\" }, { \"United States\", \"Atlanta\" }, { \"Germany\", \"Berlin\"}, { \"Germany\", \"Frankfurt\"} } ) Use the custom table from exercice 5 to filter the Geography table and return only the continents that are filtered by your Countries Use a FILTER operation Use a Join operation DEFINE VAR customTable = DATATABLE ( \"RegionCountryName\", STRING, \"City\", STRING, { { \"United States\", \"New York\" }, { \"United States\", \"Los Angeles\" }, { \"United States\", \"Miami\" }, { \"United States\", \"Atlanta\" }, { \"Germany\", \"Berlin\" }, { \"Germany\", \"Frankfurt\" } } ) VAR geoTable = SELECTCOLUMNS ( Geography, \"Geography[RegionCountryName]\", Geography[RegionCountryName], \"ContinentName\", Geography[ContinentName] ) VAR filterCountriesWithLineage = TREATAS ( DISTINCT ( SELECTCOLUMNS ( customTable, \"Geography[RegionCountryName]\", [RegionCountryName] ) ), Geography[RegionCountryName] ) VAR filterCountriesNoLineage = DISTINCT ( SELECTCOLUMNS ( customTable, \"Geography[RegionCountryName]\", [RegionCountryName] ) ) // A withFilter (TREATAS not required as lineage is there with specifing RegionContryName) EVALUATE DISTINCT ( FILTER ( geoTable, [RegionCountryName] IN filterCountries ) ) // B with Join Requires data lineage EVALUATE NATURALINNERJOIN(geoTable, filterCountriesWithLineage) Create a custom table SpecialDiscount with two Rows StartDate (DATETIME) 1/1/2013 And EndDate (DATETIME) 1/6/2013 AM And Discount (DOUBLE) 0.10 StartDate (DATETIME) 1/6/2013 And EndDate (DATETIME) 31/12/2013 And Discount (DOUBLE) 0.30 StartDate (DATETIME) 1/6/2013 And EndDate (DATETIME) 31/12/2013 And Discount (DOUBLE) 0.30 Calculate a table that gives any order a special discount, that has not already got a discount via a promotion DEFINE VAR tblSpecialDiscount = DATATABLE ( \"StartDate\", DATETIME, \"EndDate\", DATETIME, \"SpecialDiscount\", DOUBLE, { { \"1/1/2013\", \"1/6/2013\", 0.1 }, { \"1/7/2013\", \"31/12/2013\", 0.3 } } ) EVALUATE ADDCOLUMNS ( CALCULATETABLE ( SUMMARIZECOLUMNS ( Sales[SalesKey], Stores[StoreName], 'Calendar'[DateKey], Promotion[PromotionName], Promotion[DiscountPercent], \"@SalesAmountNoDiscount\", SUM ( Sales[SalesAmount] ) ), 'Calendar'[Year] = 2013 ), \"SalesAmountStandDiscount\", ( 1 - Promotion[DiscountPercent] ) * [@SalesAmountNoDiscount], \"SalesAmountSpecialDiscount\", IF ( Promotion[DiscountPercent] <> 0, 0, MAXX ( FILTER( tblSpecialDiscount, [StartDate] <= 'Calendar'[DateKey] && [EndDate] >= 'Calendar'[DateKey] ), (1-[SpecialDiscount]) * [@SalesAmountNoDiscount] ) ) ) ) )","title":"Lab Solution"},{"location":"02-AdvancedConcepts/07_Solution/#lab-solution","text":"Query the following table expression in DAX studio agains the Contos PowerBI model: Return the entire Calendar EVALUATE 'Calendar' Create a table with Product Category, Product Subcategory, Sales Year, and total Sales Amount EVALUATE SUMMARIZECOLUMNS ( ProductCategory[ProductCategory], ProductSubcategory[ProductSubcategory], 'Calendar'[YearName], \"Profit\", [Profit] ) Create a table that includes Year and Date from calendar for the year 2006 // Option A: Use FILTER EVALUATE FILTER ( SELECTCOLUMNS ( 'Calendar', \"@Date\", 'Calendar'[Date], \"@Year\", 'Calendar'[YearName] ), [@Year] = \"2006\" ) // Option B: Use CALCULATETABLE EVALUATE CALCULATETABLE( SELECTCOLUMNS ( 'Calendar', \"@Date\", 'Calendar'[Date], \"@Year\", 'Calendar'[YearName] ), 'Calendar'[Year] = 2006 ) Create a table that contains all Products with Profit for year 2005, the Average Sales Quantity per Order for June 2011 and the profit margin for alle years (Sales - Cost) / Sales EVALUATE ADDCOLUMNS ( VALUES ( ProductCategory ), \"Profit2006\", FORMAT ( CALCULATE ( [Profit], 'Calendar'[Year] = 2011 ), \"\"\"US$\"\" #,0.00\" ), \"AvgSalesLast30Days\", CALCULATE ( AVERAGE ( Sales[SalesQuantity] ), 'Calendar'[Year] = 2011, 'Calendar'[MonthName] = \"July\" ), \"ProfitMargin\", FORMAT ( DIVIDE ( [Profit], SUM ( sales[SalesAmount] ) ), \"Percent\" )) Create a custom table with RegionCountryName (United States and Germany as Values) and City (Custom cities). EVALUATE DATATABLE ( \"RegionCountryName\", STRING, \"City\", STRING, { { \"United States\", \"New York\" }, { \"United States\", \"Los Angeles\" }, { \"United States\", \"Miami\" }, { \"United States\", \"Atlanta\" }, { \"Germany\", \"Berlin\"}, { \"Germany\", \"Frankfurt\"} } ) Use the custom table from exercice 5 to filter the Geography table and return only the continents that are filtered by your Countries Use a FILTER operation Use a Join operation DEFINE VAR customTable = DATATABLE ( \"RegionCountryName\", STRING, \"City\", STRING, { { \"United States\", \"New York\" }, { \"United States\", \"Los Angeles\" }, { \"United States\", \"Miami\" }, { \"United States\", \"Atlanta\" }, { \"Germany\", \"Berlin\" }, { \"Germany\", \"Frankfurt\" } } ) VAR geoTable = SELECTCOLUMNS ( Geography, \"Geography[RegionCountryName]\", Geography[RegionCountryName], \"ContinentName\", Geography[ContinentName] ) VAR filterCountriesWithLineage = TREATAS ( DISTINCT ( SELECTCOLUMNS ( customTable, \"Geography[RegionCountryName]\", [RegionCountryName] ) ), Geography[RegionCountryName] ) VAR filterCountriesNoLineage = DISTINCT ( SELECTCOLUMNS ( customTable, \"Geography[RegionCountryName]\", [RegionCountryName] ) ) // A withFilter (TREATAS not required as lineage is there with specifing RegionContryName) EVALUATE DISTINCT ( FILTER ( geoTable, [RegionCountryName] IN filterCountries ) ) // B with Join Requires data lineage EVALUATE NATURALINNERJOIN(geoTable, filterCountriesWithLineage) Create a custom table SpecialDiscount with two Rows StartDate (DATETIME) 1/1/2013 And EndDate (DATETIME) 1/6/2013 AM And Discount (DOUBLE) 0.10 StartDate (DATETIME) 1/6/2013 And EndDate (DATETIME) 31/12/2013 And Discount (DOUBLE) 0.30 StartDate (DATETIME) 1/6/2013 And EndDate (DATETIME) 31/12/2013 And Discount (DOUBLE) 0.30 Calculate a table that gives any order a special discount, that has not already got a discount via a promotion DEFINE VAR tblSpecialDiscount = DATATABLE ( \"StartDate\", DATETIME, \"EndDate\", DATETIME, \"SpecialDiscount\", DOUBLE, { { \"1/1/2013\", \"1/6/2013\", 0.1 }, { \"1/7/2013\", \"31/12/2013\", 0.3 } } ) EVALUATE ADDCOLUMNS ( CALCULATETABLE ( SUMMARIZECOLUMNS ( Sales[SalesKey], Stores[StoreName], 'Calendar'[DateKey], Promotion[PromotionName], Promotion[DiscountPercent], \"@SalesAmountNoDiscount\", SUM ( Sales[SalesAmount] ) ), 'Calendar'[Year] = 2013 ), \"SalesAmountStandDiscount\", ( 1 - Promotion[DiscountPercent] ) * [@SalesAmountNoDiscount], \"SalesAmountSpecialDiscount\", IF ( Promotion[DiscountPercent] <> 0, 0, MAXX ( FILTER( tblSpecialDiscount, [StartDate] <= 'Calendar'[DateKey] && [EndDate] >= 'Calendar'[DateKey] ), (1-[SpecialDiscount]) * [@SalesAmountNoDiscount] ) ) ) ) )","title":"Lab Solution"},{"location":"03-AdvancedDAX/01_NeedToKnowFunctions/","text":"Need to know Functions SELECTEDVALUE Returns the value when there\u2019s only one value in the specified column, otherwise returns the alternate result. SWITCH Returns different results depending on the value of an expression. FORMAT Converts a value to text in the specified number format. CONVERT Convert an expression to the specified data type. COUNTROWS Counts the number of rows in a table. ISFILTERED Returns true when there are direct filters on the specified column. ISCROSSFILTERED Returns true when the specified table or column is crossfiltered. FIRSTNONBLANK Returns the first value in the column for which the expression has a non blank value. FIRSTNONBLANKVALUE Returns the first non blank value of the expression that evaluated for the column. RANKX Returns the rank of an expression evaluated in the current context in the list of values for the expression evaluated for each row in the specified table. Time Intelligence Time intelligence functions support calculations to compare and aggregate data over time periods, supporting days, months, quarters, and years. You need a gapless Date-Table with a Date column in your model to make these functions work. DATESYTD Returns a set of dates in the year up to the last date visible in the filter context. SAMEPERIODLASTYEAR Returns a set of dates in the current selection from the previous year. DATEADD Moves the given set of dates by a specified interval. And many more\u2026 Link","title":"Need to know Functions"},{"location":"03-AdvancedDAX/01_NeedToKnowFunctions/#need-to-know-functions","text":"SELECTEDVALUE Returns the value when there\u2019s only one value in the specified column, otherwise returns the alternate result. SWITCH Returns different results depending on the value of an expression. FORMAT Converts a value to text in the specified number format. CONVERT Convert an expression to the specified data type. COUNTROWS Counts the number of rows in a table. ISFILTERED Returns true when there are direct filters on the specified column. ISCROSSFILTERED Returns true when the specified table or column is crossfiltered. FIRSTNONBLANK Returns the first value in the column for which the expression has a non blank value. FIRSTNONBLANKVALUE Returns the first non blank value of the expression that evaluated for the column. RANKX Returns the rank of an expression evaluated in the current context in the list of values for the expression evaluated for each row in the specified table.","title":"Need to know Functions"},{"location":"03-AdvancedDAX/01_NeedToKnowFunctions/#time-intelligence","text":"Time intelligence functions support calculations to compare and aggregate data over time periods, supporting days, months, quarters, and years. You need a gapless Date-Table with a Date column in your model to make these functions work. DATESYTD Returns a set of dates in the year up to the last date visible in the filter context. SAMEPERIODLASTYEAR Returns a set of dates in the current selection from the previous year. DATEADD Moves the given set of dates by a specified interval. And many more\u2026 Link","title":"Time Intelligence"},{"location":"03-AdvancedDAX/02_TheAllFamily%20copy/","text":"The All Family","title":"The All Family"},{"location":"03-AdvancedDAX/02_TheAllFamily%20copy/#the-all-family","text":"","title":"The All Family"},{"location":"03-AdvancedDAX/03_SemiAndNoneAdditiveMeasures%20copy/","text":"None-Additive and Semi-Additive Measures Semi-Additive-Measures Definition: Can be summed across some dimensions, but not all. Balance amounts are common semi-additive facts because they are additive across all dimensions except time. Calculation: LastBalanceAllCustomers := VAR LastDateAllCustomers = CALCULATETABLE ( LASTNONBLANK ( 'Date'[Date], COUNTROWS ( RELATEDTABLE ( Balances ) ) ), ALL ( Balances[Name] ) ) VAR Result = CALCULATE ( SUM( Balances[Balance] ), LastDateAllCustomers ) RETURN Result None-Addive-Measures Definition: Some measures are completely non-additive, such as ratios. A good approach for non-additive facts is, where possible, to store the fully additive components of the non-additive measure and sum these components into the \ufb01nal answer set before calculating the \ufb01nal non-additive fact. Calculation: SalesPerWorkingDay = DIVIDE( [Sales Amount], [NumOfWorkingDays] )","title":"None-Additive and Semi-Additive Measures"},{"location":"03-AdvancedDAX/03_SemiAndNoneAdditiveMeasures%20copy/#none-additive-and-semi-additive-measures","text":"","title":"None-Additive and Semi-Additive Measures"},{"location":"03-AdvancedDAX/03_SemiAndNoneAdditiveMeasures%20copy/#semi-additive-measures","text":"Definition: Can be summed across some dimensions, but not all. Balance amounts are common semi-additive facts because they are additive across all dimensions except time. Calculation: LastBalanceAllCustomers := VAR LastDateAllCustomers = CALCULATETABLE ( LASTNONBLANK ( 'Date'[Date], COUNTROWS ( RELATEDTABLE ( Balances ) ) ), ALL ( Balances[Name] ) ) VAR Result = CALCULATE ( SUM( Balances[Balance] ), LastDateAllCustomers ) RETURN Result","title":"Semi-Additive-Measures"},{"location":"03-AdvancedDAX/03_SemiAndNoneAdditiveMeasures%20copy/#none-addive-measures","text":"Definition: Some measures are completely non-additive, such as ratios. A good approach for non-additive facts is, where possible, to store the fully additive components of the non-additive measure and sum these components into the \ufb01nal answer set before calculating the \ufb01nal non-additive fact. Calculation: SalesPerWorkingDay = DIVIDE( [Sales Amount], [NumOfWorkingDays] )","title":"None-Addive-Measures"},{"location":"03-AdvancedDAX/04_CalculationGroups/","text":"Calculation Groups In 2019, DAX received a major update with the introduction of calculation groups. Calculation groups are a utility feature inspired from a similar feature available in MDX, known as calculated members Calculation Groups allow you to write calculations in a more generic way. Scenario Imagine you want to use time intelligence to display your measure with different scenarios, like Actual value, Year-To-Date or Previous year. this can be realized as follows:","title":"Calculation Groups"},{"location":"03-AdvancedDAX/04_CalculationGroups/#calculation-groups","text":"In 2019, DAX received a major update with the introduction of calculation groups. Calculation groups are a utility feature inspired from a similar feature available in MDX, known as calculated members Calculation Groups allow you to write calculations in a more generic way. Scenario Imagine you want to use time intelligence to display your measure with different scenarios, like Actual value, Year-To-Date or Previous year. this can be realized as follows:","title":"Calculation Groups"},{"location":"03-AdvancedDAX/05_Hierarchies%20copy/","text":"Working with Hierachies Hierarchies are oftentimes present in data models to make it easier for the user to slice and dice using predefi ed exploration paths. Nevertheless, DAX does not have any built-in function providing a calculation over hierarchies. Computing a simple calculation like the ratio to parent requires complex DAX code, and the support for calculations over hierarchies proves to be a challenge in general. Hierarchical Calculations PercOnParent := VAR CurrentSales = [Sales Amount] VAR SubcategorySales = CALCULATE ( [Sales Amount], ALLSELECTED ( Product[Product Name] ) ) VAR CategorySales = CALCULATE ( [Sales Amount], ALLSELECTED ( Product[Subcategory] ) ) VAR TotalSales = CALCULATE ( [Sales Amount], ALLSELECTED ( Product[Category] ) ) VAR RatioToParent = IF ( ISINSCOPE ( Product[Product Name] ), DIVIDE ( CurrentSales, SubcategorySales ), IF ( ISINSCOPE ( Product[Subcategory] ), DIVIDE ( CurrentSales, CategorySales ), IF ( ISINSCOPE ( Product[Category] ), DIVIDE ( CurrentSales, TotalSales ) ) ) ) RETURN RatioToParent ISINSCOPE Returns true when the specified column is the level in a hierarchy of levels. Parent-Child-Hierarchies PATH Returns a string which contains a delimited list of IDs, starting with the top/root of a hierarchy and ending with the specified ID. PATHCONTAINS Returns TRUE if the specified Item exists within the specified Path. PATHITEM Returns the nth item in the delimited list produced by the Path function. PATHLENGTH Returns returns the number of items in a particular path string. This function returns 1 for the path generated for an ID at the top/root of a hierarchy.","title":"Working with Hierachies"},{"location":"03-AdvancedDAX/05_Hierarchies%20copy/#working-with-hierachies","text":"Hierarchies are oftentimes present in data models to make it easier for the user to slice and dice using predefi ed exploration paths. Nevertheless, DAX does not have any built-in function providing a calculation over hierarchies. Computing a simple calculation like the ratio to parent requires complex DAX code, and the support for calculations over hierarchies proves to be a challenge in general.","title":"Working with Hierachies"},{"location":"03-AdvancedDAX/05_Hierarchies%20copy/#hierarchical-calculations","text":"PercOnParent := VAR CurrentSales = [Sales Amount] VAR SubcategorySales = CALCULATE ( [Sales Amount], ALLSELECTED ( Product[Product Name] ) ) VAR CategorySales = CALCULATE ( [Sales Amount], ALLSELECTED ( Product[Subcategory] ) ) VAR TotalSales = CALCULATE ( [Sales Amount], ALLSELECTED ( Product[Category] ) ) VAR RatioToParent = IF ( ISINSCOPE ( Product[Product Name] ), DIVIDE ( CurrentSales, SubcategorySales ), IF ( ISINSCOPE ( Product[Subcategory] ), DIVIDE ( CurrentSales, CategorySales ), IF ( ISINSCOPE ( Product[Category] ), DIVIDE ( CurrentSales, TotalSales ) ) ) ) RETURN RatioToParent ISINSCOPE Returns true when the specified column is the level in a hierarchy of levels.","title":"Hierarchical Calculations"},{"location":"03-AdvancedDAX/05_Hierarchies%20copy/#parent-child-hierarchies","text":"PATH Returns a string which contains a delimited list of IDs, starting with the top/root of a hierarchy and ending with the specified ID. PATHCONTAINS Returns TRUE if the specified Item exists within the specified Path. PATHITEM Returns the nth item in the delimited list produced by the Path function. PATHLENGTH Returns returns the number of items in a particular path string. This function returns 1 for the path generated for an ID at the top/root of a hierarchy.","title":"Parent-Child-Hierarchies"},{"location":"03-AdvancedDAX/06_RowLevelSecurity%20copy/","text":"Row Level Security Secure the data according to the privileges of the current user connected to the model Technically, this is nothing more than applying a filter to the data. The difference to regular filtering in the report is that the filtering is done automatically via roles and cannot be influenced by the user.","title":"Row Level Security"},{"location":"03-AdvancedDAX/06_RowLevelSecurity%20copy/#row-level-security","text":"Secure the data according to the privileges of the current user connected to the model Technically, this is nothing more than applying a filter to the data. The difference to regular filtering in the report is that the filtering is done automatically via roles and cannot be influenced by the user.","title":"Row Level Security"},{"location":"03-AdvancedDAX/07_HandsOn/","text":"Hands On Advanced DAX SWITCH In this example, we want to use the SWITCH function to execute different blocks of code depending on how many ProductCategories have been selected. If only one has been selected, then the card visual should only show the one value, in case of multiple selection the categories should be concatenated with \"and\" and also in case of no selection this should be shown. For illustration the function ISFILTERED and HASONEVALUE was used. This was the common way to select a chosen value until the implementation of the SELECTEDVALUE function. Switch = VAR varSelectedValue = IF ( NOT ISFILTERED ( ProductCategory[ProductCategory] ), \"NotFiltered\", IF ( HASONEVALUE ( ProductCategory[ProductCategory] ), \"OneValue\", \"MultipleValues\" ) ) VAR varSwitch = SWITCH ( varSelectedValue, \"OneValue\", CONCATENATE ( \"Selected Value is: \", SELECTEDVALUE ( ProductCategory[ProductCategory] ) ), \"MultipleValues\", CONCATENATE ( \"Selected Values are: \", CONCATENATEX ( VALUES ( ProductCategory[ProductCategory] ), ProductCategory[ProductCategory], \" and \" ) ), \"No Value selected\" ) RETURN varSwitch Format With the help of the FORMAT function, measures can be displayed in any format. In this example we will read a selected format and apply it to the measure. Note that not every format is applicable to every measure. Format_Profit = VAR varSelectedFormatName = SELECTEDVALUE ( 'format'[FormatName], \"MoreSelected\" ) VAR varSelectedFormat = SELECTEDVALUE ( 'format'[Format], \"MoreSelected\" ) RETURN IFERROR ( FORMAT ( [Profit], varSelectedFormat ), \"Error Format\" ) RANKX simple With this simple RANKX function we want to show which products achieve the highest profit. Rankx_Simple_Profit = //Use All not values to remove filter from a single Product VAR varProductProfit = ALL ( 'Product'[ProductName] ) VAR varRank = RANKX ( varProductProfit, [Profit] ) //Avoid a Rank for Total Row RETURN IF ( ISFILTERED ( 'Product' ), varRank ) RANKX with custom Rank In this somewhat more complex example, the possibility of an individual evaluation of the best products is intended to be enabled, whereby the profit of the top X products is displayed, while all others are displayed on \"Ohthers\". In addition to the DAX calculation, another table must be created that integrates the row \"ohters\" into the model. Table Product Ranking = UNION ( SELECTCOLUMNS ( ALLNOBLANKROW ( 'Product'[ProductName]), \"Ranking name\", 'Product'[ProductName], \"Ranking group\", \"Best Products\" ), { ( \"Other\", \"Other\" ) } ) Measure Rankx_Other = IF ( ISINSCOPE ( 'Product Ranking'[Ranking group] ), VAR NumOfProducts = SELECTEDVALUE('TopN'[Value],1) VAR RankingGroup = SELECTEDVALUE ( 'Product Ranking'[Ranking group] ) VAR TopProducts = TOPN ( NumOfProducts, ALLSELECTED ( 'Product Ranking' ), [Profit] ) RETURN SWITCH ( RankingGroup, \"Best Products\", CALCULATE ( [Profit], KEEPFILTERS ( TopProducts ) ), \"Other\", IF ( NOT ISINSCOPE ( 'Product Ranking'[Ranking Name] ), VAR TopAmount = CALCULATE ( [Profit], TopProducts ) VAR AllAmount = CALCULATE ( [Profit], ALLSELECTED ( 'Product Ranking' ) ) VAR OtherAmt = AllAmount - TopAmount RETURN OtherAmt ) ), [Profit] ) Semi Additive Measures simple example of semi addive measures. The first measure shows an aggregation of delta values. This option is useful when, for example, stocks have to be calculated. The second example shows in contrast the profit at the level of the last profit date Semi_Additive_Simple = var varMaxDate = MAX('Calendar'[DateKey]) var varProfit = CALCULATE([Profit], 'Calendar'[DateKey] <= varMaxDate) return varProfit Semi_Addivite_lastNone = var LastSalesDate = LASTNONBLANK('Calendar'[DateKey], [Profit]) Return CALCULATE([Profit], 'Calendar'[DateKey] = LastSalesDate) ISINSCOPE With the help of the ISINSCOPE function we can find ratio values on different hierarchy levels. Profit_Ratio_Hierarchy = VAR Profit = [Profit] VAR totalProfitManufacture = CALCULATE ( [Profit], REMOVEFILTERS ( 'Product'[ProductName] ) ) RETURN SWITCH ( TRUE (), AND ( ISINSCOPE ( 'Product'[ProductName] ), NOT ISBLANK ( Profit ) ), DIVIDE ( Profit, totalProfitManufacture ), AND ( ISINSCOPE ( 'Product'[Manufacturer] ), NOT ISBLANK ( Profit ) ), DIVIDE ( Profit, profit ), BLANK () )","title":"Hands On Advanced DAX"},{"location":"03-AdvancedDAX/07_HandsOn/#hands-on-advanced-dax","text":"","title":"Hands On Advanced DAX"},{"location":"03-AdvancedDAX/07_HandsOn/#switch","text":"In this example, we want to use the SWITCH function to execute different blocks of code depending on how many ProductCategories have been selected. If only one has been selected, then the card visual should only show the one value, in case of multiple selection the categories should be concatenated with \"and\" and also in case of no selection this should be shown. For illustration the function ISFILTERED and HASONEVALUE was used. This was the common way to select a chosen value until the implementation of the SELECTEDVALUE function. Switch = VAR varSelectedValue = IF ( NOT ISFILTERED ( ProductCategory[ProductCategory] ), \"NotFiltered\", IF ( HASONEVALUE ( ProductCategory[ProductCategory] ), \"OneValue\", \"MultipleValues\" ) ) VAR varSwitch = SWITCH ( varSelectedValue, \"OneValue\", CONCATENATE ( \"Selected Value is: \", SELECTEDVALUE ( ProductCategory[ProductCategory] ) ), \"MultipleValues\", CONCATENATE ( \"Selected Values are: \", CONCATENATEX ( VALUES ( ProductCategory[ProductCategory] ), ProductCategory[ProductCategory], \" and \" ) ), \"No Value selected\" ) RETURN varSwitch","title":"SWITCH"},{"location":"03-AdvancedDAX/07_HandsOn/#format","text":"With the help of the FORMAT function, measures can be displayed in any format. In this example we will read a selected format and apply it to the measure. Note that not every format is applicable to every measure. Format_Profit = VAR varSelectedFormatName = SELECTEDVALUE ( 'format'[FormatName], \"MoreSelected\" ) VAR varSelectedFormat = SELECTEDVALUE ( 'format'[Format], \"MoreSelected\" ) RETURN IFERROR ( FORMAT ( [Profit], varSelectedFormat ), \"Error Format\" )","title":"Format"},{"location":"03-AdvancedDAX/07_HandsOn/#rankx-simple","text":"With this simple RANKX function we want to show which products achieve the highest profit. Rankx_Simple_Profit = //Use All not values to remove filter from a single Product VAR varProductProfit = ALL ( 'Product'[ProductName] ) VAR varRank = RANKX ( varProductProfit, [Profit] ) //Avoid a Rank for Total Row RETURN IF ( ISFILTERED ( 'Product' ), varRank )","title":"RANKX simple"},{"location":"03-AdvancedDAX/07_HandsOn/#rankx-with-custom-rank","text":"In this somewhat more complex example, the possibility of an individual evaluation of the best products is intended to be enabled, whereby the profit of the top X products is displayed, while all others are displayed on \"Ohthers\". In addition to the DAX calculation, another table must be created that integrates the row \"ohters\" into the model. Table Product Ranking = UNION ( SELECTCOLUMNS ( ALLNOBLANKROW ( 'Product'[ProductName]), \"Ranking name\", 'Product'[ProductName], \"Ranking group\", \"Best Products\" ), { ( \"Other\", \"Other\" ) } ) Measure Rankx_Other = IF ( ISINSCOPE ( 'Product Ranking'[Ranking group] ), VAR NumOfProducts = SELECTEDVALUE('TopN'[Value],1) VAR RankingGroup = SELECTEDVALUE ( 'Product Ranking'[Ranking group] ) VAR TopProducts = TOPN ( NumOfProducts, ALLSELECTED ( 'Product Ranking' ), [Profit] ) RETURN SWITCH ( RankingGroup, \"Best Products\", CALCULATE ( [Profit], KEEPFILTERS ( TopProducts ) ), \"Other\", IF ( NOT ISINSCOPE ( 'Product Ranking'[Ranking Name] ), VAR TopAmount = CALCULATE ( [Profit], TopProducts ) VAR AllAmount = CALCULATE ( [Profit], ALLSELECTED ( 'Product Ranking' ) ) VAR OtherAmt = AllAmount - TopAmount RETURN OtherAmt ) ), [Profit] )","title":"RANKX with custom Rank"},{"location":"03-AdvancedDAX/07_HandsOn/#semi-additive-measures","text":"simple example of semi addive measures. The first measure shows an aggregation of delta values. This option is useful when, for example, stocks have to be calculated. The second example shows in contrast the profit at the level of the last profit date Semi_Additive_Simple = var varMaxDate = MAX('Calendar'[DateKey]) var varProfit = CALCULATE([Profit], 'Calendar'[DateKey] <= varMaxDate) return varProfit Semi_Addivite_lastNone = var LastSalesDate = LASTNONBLANK('Calendar'[DateKey], [Profit]) Return CALCULATE([Profit], 'Calendar'[DateKey] = LastSalesDate)","title":"Semi Additive Measures"},{"location":"03-AdvancedDAX/07_HandsOn/#isinscope","text":"With the help of the ISINSCOPE function we can find ratio values on different hierarchy levels. Profit_Ratio_Hierarchy = VAR Profit = [Profit] VAR totalProfitManufacture = CALCULATE ( [Profit], REMOVEFILTERS ( 'Product'[ProductName] ) ) RETURN SWITCH ( TRUE (), AND ( ISINSCOPE ( 'Product'[ProductName] ), NOT ISBLANK ( Profit ) ), DIVIDE ( Profit, totalProfitManufacture ), AND ( ISINSCOPE ( 'Product'[Manufacturer] ), NOT ISBLANK ( Profit ) ), DIVIDE ( Profit, profit ), BLANK () )","title":"ISINSCOPE"},{"location":"03-AdvancedDAX/08_Lab/","text":"Lab 3: Advanced DAX Create a Measure ProfitYTD with fiscal year from 01.06. - 31.5 and create a Measre ProfitPY (previous year) Illustrate the productCategory profit for 2013 with Year-over-Year value in $ and percent (incl. format) Create the same output like in 2 by using calculation groups (Actual, YTD, PY, YoYEur, YoYPer Create a running total measure YearCount, that counts up the years (2005=1, 2006=2,\u2026). Display your result in a table Generate a custom table from 1 to 10. Create a Ranking Measures that rankes the Stores And ProductCategory and dynamically filter the top x rank based on your created table. Use the table from task 5 and add the date on which the largest profit was achieved in the year or selected period Calculate the percentage of profit of each sub-category in relation to the parent ProductCategory. On ProductCategory level this should result in 100%. Implement your own dynamic row level Security.","title":"Lab 3: Advanced DAX"},{"location":"03-AdvancedDAX/08_Lab/#lab-3-advanced-dax","text":"Create a Measure ProfitYTD with fiscal year from 01.06. - 31.5 and create a Measre ProfitPY (previous year) Illustrate the productCategory profit for 2013 with Year-over-Year value in $ and percent (incl. format) Create the same output like in 2 by using calculation groups (Actual, YTD, PY, YoYEur, YoYPer Create a running total measure YearCount, that counts up the years (2005=1, 2006=2,\u2026). Display your result in a table Generate a custom table from 1 to 10. Create a Ranking Measures that rankes the Stores And ProductCategory and dynamically filter the top x rank based on your created table. Use the table from task 5 and add the date on which the largest profit was achieved in the year or selected period Calculate the percentage of profit of each sub-category in relation to the parent ProductCategory. On ProductCategory level this should result in 100%. Implement your own dynamic row level Security.","title":"Lab 3: Advanced DAX"},{"location":"03-AdvancedDAX/09_Solution/","text":"Lab 3: Solution Create a Measure ProfitYTD with fiscal year from 01.06. - 31.5 and create a Measre ProfitPY (previous year) ProfitYTD = CALCULATE([Profit], DATESYTD('Calendar'[Date], \"31-05\")) Illustrate the productCategory profit for 2013 with Year-over-Year value in $ and percent (incl. format) ProfitYoY_Eur = VAR varProfitActual = [Profit] VAR varProfitPy = [ProfitPY] VAR varYoY = varProfitActual - varProfitPy RETURN IF ( NOT ISBLANK ( varYoY ), FORMAT ( varYoY, \"Currency\" ) ) ProfitYoY_Per = var varYoY = DIVIDE([ProfitYoY_Eur], [ProfitPY]) RETURN IF(not ISBLANK(varYoY), varYoY) Create the same output like in 2 by using calculation groups (Actual, YTD, PY, YoYEur, YoYPer Actual = SELECTEDMEASURE () YTD = IF ( ISSELECTEDMEASURE ( [Profit] ), CALCULATE ( SELECTEDMEASURE (), DATESYTD ( 'Calendar'[DateKey], \"06-30\" ) ), SELECTEDMEASURE () ) PY = IF ( ISSELECTEDMEASURE ( [Profit] ), CALCULATE ( SELECTEDMEASURE (), SAMEPERIODLASTYEAR ( 'Calendar'[DateKey] ) ), SELECTEDMEASURE () ) YoY_Eur = VAR varProfitActual = SELECTEDMEASURE () VAR varProfitPy = CALCULATE ( SELECTEDMEASURE (), SAMEPERIODLASTYEAR ( 'Calendar'[DateKey] ) ) VAR varYoY = varProfitActual - varProfitPy RETURN varYoY YoY_Per = VAR varProfitActual = SELECTEDMEASURE () VAR varProfitPy = CALCULATE ( SELECTEDMEASURE (), SAMEPERIODLASTYEAR ( 'Calendar'[DateKey] ) ) VAR varYoY = DIVIDE ( [ProfitYoY_Eur], [ProfitPY] ) RETURN IF ( NOT ISBLANK ( varYoY ), FORMAT ( varYoY, \"Percent\" ) ) Create a running total measure YearCount, that counts up the years (2005=1, 2006=2,\u2026). Display your result in a table YearCount = COUNTROWS ( FILTER ( ALL ( 'Calendar'[Year] ), 'Calendar'[Year] <= MAX ( 'Calendar'[Year] ) ) ) Generate a custom table from 1 to 10. Create a Ranking Measures that rankes the Stores And ProductCategory and dynamically filter the top x rank based on your created table. TopN = GENERATESERIES(1,10, 1) RankProfit = VAR varTopN = SELECTEDVALUE ( 'TopN'[Value], 1 ) VAR varStoresProduct = TOPN ( varTopN, CROSSJOIN ( ALL ( Stores[StoreName] ), ALL ( ProductCategory[ProductCategory] ) ), [Profit] ) VAR varRank = RANKX ( varStoresProduct, [Profit],, DESC ) RETURN IF ( varRank <= varTopN, INT ( varRank ), CONCATENATE ( \"Not Top \", VALUE ( varTopN ) ) ) Use the table from task 5 and add the date on which the largest profit was achieved in the year or selected period TopProfitDDate = VAR varStoresProfits = SUMMARIZE ( Sales, Sales[cProfit], 'Calendar'[Date] ) VAR varTop = TOPN ( 1, varStoresProfits, [cProfit], DESC ) RETURN MAXX ( varTop, [Date] ) Calculate the percentage of profit of each sub-category in relation to the parent ProductCategory. On ProductCategory level this should result in 100%. ProfitRatioHierarchy = VAR Profit = [Profit] VAR totalProductCategory = CALCULATE ( [Profit], REMOVEFILTERS ( ProductSubcategory[ProductSubcategory] ) ) RETURN SWITCH ( TRUE (), AND ( ISINSCOPE ( ProductSubcategory[ProductSubcategory] ), NOT ISBLANK ( Profit ) ), DIVIDE ( Profit, totalProductCategory ), AND ( ISINSCOPE ( 'ProductCategory'[ProductCategory] ), NOT ISBLANK ( Profit ) ), DIVIDE ( Profit, profit ), BLANK () ) Implement your own dynamic row level Security. RLS_CountryRegion = DATATABLE ( \"User\", STRING, \"RegionCountryName\", STRING, { { \"m.riehle@oraylis.de\", \"Germany\" }, { \"m.riehle@oraylis.de\", \"United States\" }, { \"m.mustermann@oraylis.de\", \"Australia\" }, { \"m.mustermann@oraylis.de\", \"Italy\" }, { \"m.mustermann@oraylis.de\", \"United Kingdom\" } } ) //In Manage Roles Filter RLS_CountryRegion [User] = USERPRINCIPALNAME ()","title":"Lab 3: Solution"},{"location":"03-AdvancedDAX/09_Solution/#lab-3-solution","text":"Create a Measure ProfitYTD with fiscal year from 01.06. - 31.5 and create a Measre ProfitPY (previous year) ProfitYTD = CALCULATE([Profit], DATESYTD('Calendar'[Date], \"31-05\")) Illustrate the productCategory profit for 2013 with Year-over-Year value in $ and percent (incl. format) ProfitYoY_Eur = VAR varProfitActual = [Profit] VAR varProfitPy = [ProfitPY] VAR varYoY = varProfitActual - varProfitPy RETURN IF ( NOT ISBLANK ( varYoY ), FORMAT ( varYoY, \"Currency\" ) ) ProfitYoY_Per = var varYoY = DIVIDE([ProfitYoY_Eur], [ProfitPY]) RETURN IF(not ISBLANK(varYoY), varYoY) Create the same output like in 2 by using calculation groups (Actual, YTD, PY, YoYEur, YoYPer Actual = SELECTEDMEASURE () YTD = IF ( ISSELECTEDMEASURE ( [Profit] ), CALCULATE ( SELECTEDMEASURE (), DATESYTD ( 'Calendar'[DateKey], \"06-30\" ) ), SELECTEDMEASURE () ) PY = IF ( ISSELECTEDMEASURE ( [Profit] ), CALCULATE ( SELECTEDMEASURE (), SAMEPERIODLASTYEAR ( 'Calendar'[DateKey] ) ), SELECTEDMEASURE () ) YoY_Eur = VAR varProfitActual = SELECTEDMEASURE () VAR varProfitPy = CALCULATE ( SELECTEDMEASURE (), SAMEPERIODLASTYEAR ( 'Calendar'[DateKey] ) ) VAR varYoY = varProfitActual - varProfitPy RETURN varYoY YoY_Per = VAR varProfitActual = SELECTEDMEASURE () VAR varProfitPy = CALCULATE ( SELECTEDMEASURE (), SAMEPERIODLASTYEAR ( 'Calendar'[DateKey] ) ) VAR varYoY = DIVIDE ( [ProfitYoY_Eur], [ProfitPY] ) RETURN IF ( NOT ISBLANK ( varYoY ), FORMAT ( varYoY, \"Percent\" ) ) Create a running total measure YearCount, that counts up the years (2005=1, 2006=2,\u2026). Display your result in a table YearCount = COUNTROWS ( FILTER ( ALL ( 'Calendar'[Year] ), 'Calendar'[Year] <= MAX ( 'Calendar'[Year] ) ) ) Generate a custom table from 1 to 10. Create a Ranking Measures that rankes the Stores And ProductCategory and dynamically filter the top x rank based on your created table. TopN = GENERATESERIES(1,10, 1) RankProfit = VAR varTopN = SELECTEDVALUE ( 'TopN'[Value], 1 ) VAR varStoresProduct = TOPN ( varTopN, CROSSJOIN ( ALL ( Stores[StoreName] ), ALL ( ProductCategory[ProductCategory] ) ), [Profit] ) VAR varRank = RANKX ( varStoresProduct, [Profit],, DESC ) RETURN IF ( varRank <= varTopN, INT ( varRank ), CONCATENATE ( \"Not Top \", VALUE ( varTopN ) ) ) Use the table from task 5 and add the date on which the largest profit was achieved in the year or selected period TopProfitDDate = VAR varStoresProfits = SUMMARIZE ( Sales, Sales[cProfit], 'Calendar'[Date] ) VAR varTop = TOPN ( 1, varStoresProfits, [cProfit], DESC ) RETURN MAXX ( varTop, [Date] ) Calculate the percentage of profit of each sub-category in relation to the parent ProductCategory. On ProductCategory level this should result in 100%. ProfitRatioHierarchy = VAR Profit = [Profit] VAR totalProductCategory = CALCULATE ( [Profit], REMOVEFILTERS ( ProductSubcategory[ProductSubcategory] ) ) RETURN SWITCH ( TRUE (), AND ( ISINSCOPE ( ProductSubcategory[ProductSubcategory] ), NOT ISBLANK ( Profit ) ), DIVIDE ( Profit, totalProductCategory ), AND ( ISINSCOPE ( 'ProductCategory'[ProductCategory] ), NOT ISBLANK ( Profit ) ), DIVIDE ( Profit, profit ), BLANK () ) Implement your own dynamic row level Security. RLS_CountryRegion = DATATABLE ( \"User\", STRING, \"RegionCountryName\", STRING, { { \"m.riehle@oraylis.de\", \"Germany\" }, { \"m.riehle@oraylis.de\", \"United States\" }, { \"m.mustermann@oraylis.de\", \"Australia\" }, { \"m.mustermann@oraylis.de\", \"Italy\" }, { \"m.mustermann@oraylis.de\", \"United Kingdom\" } } ) //In Manage Roles Filter RLS_CountryRegion [User] = USERPRINCIPALNAME ()","title":"Lab 3: Solution"},{"location":"04-PracticalExamples/01_DateDiff/","text":"Date Diff This example is about calculating the difference of two dates. In our case we want to calculate the time between the booking of the hours and the invoicing. Two separate time dimensions have been created in the model for this purpose. Option 1: Using virtual Relationship In this approach, we iterate over all posted sales. Since we are working on row level using the row context, we can use the LOOKUP function to pull the corresponding dates from the date tables. Then we can calculate the difference using the DATEDIFF function DaysToBillingLookUp = VAR tblRevenue = SELECTCOLUMNS ( FactRevenue, \"FactRevenue[DateKey]\", FactRevenue[DateKey], \"FactRevenue[DateKeyBilling]\", FactRevenue[DateKeyBilling] ) RETURN AVERAGEX ( ADDCOLUMNS ( tblRevenue, \"BookingDate\", LOOKUPVALUE ( DimDate[Date], DimDate[DateKey], FactRevenue[DateKey] ), \"BillingDate\", LOOKUPVALUE ( DimDate[Date], DimDate[DateKey], FactRevenue[DateKeyBilling] ), \"@DateDiff\", INT ( LOOKUPVALUE ( DimDate[Date], DimDate[DateKey], FactRevenue[DateKeyBilling] ) - LOOKUPVALUE ( DimDate[Date], DimDate[DateKey], FactRevenue[DateKey] ) ) ), [@DateDiff] ) Option 2: Using physical Relationship The simpler and also from a performance point of view better approach, is to use the RELATED function. Here we also iterate over the facts, but we can easily reach the corresponding dates through the expanded table and thus calculate the difference. DayToBillingRelated = AVERAGEX(FactRevenue, DATEDIFF(RELATED(DimDate[Date]), RELATED(DimDateBilling[DateBilling]), DAY)) Result","title":"Date Diff"},{"location":"04-PracticalExamples/01_DateDiff/#date-diff","text":"This example is about calculating the difference of two dates. In our case we want to calculate the time between the booking of the hours and the invoicing. Two separate time dimensions have been created in the model for this purpose.","title":"Date Diff"},{"location":"04-PracticalExamples/01_DateDiff/#option-1-using-virtual-relationship","text":"In this approach, we iterate over all posted sales. Since we are working on row level using the row context, we can use the LOOKUP function to pull the corresponding dates from the date tables. Then we can calculate the difference using the DATEDIFF function DaysToBillingLookUp = VAR tblRevenue = SELECTCOLUMNS ( FactRevenue, \"FactRevenue[DateKey]\", FactRevenue[DateKey], \"FactRevenue[DateKeyBilling]\", FactRevenue[DateKeyBilling] ) RETURN AVERAGEX ( ADDCOLUMNS ( tblRevenue, \"BookingDate\", LOOKUPVALUE ( DimDate[Date], DimDate[DateKey], FactRevenue[DateKey] ), \"BillingDate\", LOOKUPVALUE ( DimDate[Date], DimDate[DateKey], FactRevenue[DateKeyBilling] ), \"@DateDiff\", INT ( LOOKUPVALUE ( DimDate[Date], DimDate[DateKey], FactRevenue[DateKeyBilling] ) - LOOKUPVALUE ( DimDate[Date], DimDate[DateKey], FactRevenue[DateKey] ) ) ), [@DateDiff] )","title":"Option 1: Using virtual Relationship"},{"location":"04-PracticalExamples/01_DateDiff/#option-2-using-physical-relationship","text":"The simpler and also from a performance point of view better approach, is to use the RELATED function. Here we also iterate over the facts, but we can easily reach the corresponding dates through the expanded table and thus calculate the difference. DayToBillingRelated = AVERAGEX(FactRevenue, DATEDIFF(RELATED(DimDate[Date]), RELATED(DimDateBilling[DateBilling]), DAY))","title":"Option 2: Using physical Relationship"},{"location":"04-PracticalExamples/01_DateDiff/#result","text":"","title":"Result"},{"location":"04-PracticalExamples/02_BudgetAllocation/","text":"Budget Allocation When distributing budget, it often happens that the granularity of the data differs. As in our example, an employee enters the hours or the revenue on a daily key. The budget, on the other hand, is planned only per engagement on a monthly key. The budget should now be broken down to the employees who are on the Engagement at the time. Preparation A fact table is needed, which assigns a monthly budget to each engagement. With the help of a bridge table, the employees are then assigned to the respective projects. model view Implementation For the implementation it is important that the budget that has already been distributed is also taken into account. In the following example, two employees are in the first month on the engagement, so these two can share the budget. In the third month, another colleague is added. Now, of course, this must not be taken into account for the first month. Therefore, only the open budget from month 2 may still be distributed BudgetAllocation = VAR Employee = SELECTEDVALUE ( DimEmployee[EmployeeKey] ) VAR Engagement = SELECTEDVALUE ( DimEnagement[EngagementCode] ) VAR maxYearMonthKey = MAX ( DimDate[YearMonthKey] ) VAR minYearMonthKey = MIN ( DimDate[YearMonthKey] ) VAR tbl = DISTINCT ( SELECTCOLUMNS ( CALCULATETABLE ( DimDate, DimDate[YearMonthKey] <= maxYearMonthKey ), \"DimDate[YearMonthKey]\", DimDate[YearMonthKey] ) ) VAR tblDateEngEmp = CROSSJOIN ( CROSSJOIN ( tbl, VALUES ( DimEmployee[EmployeeKey] ) ), VALUES ( DimEnagement[EngagementCode] ) ) VAR tblGenerate = GENERATE ( tblDateEngEmp, VAR varYearMonthKey = [YearMonthKey] VAR varEmployeeKey = [EmployeeKey] VAR varEngagementCode = [EngagementCode] VAR varRevenue = [Revenue] VAR EmployeeAllocatedBudget = COUNTROWS ( CALCULATETABLE ( BridgeEmployeeEngagement, DimEmployee[EmployeeKey] = varEmployeeKey, DimEnagement[EngagementCode] = varEngagementCode, DimDate[YearMonthKey] = varYearMonthKey ) ) VAR varBudget = IF ( EmployeeAllocatedBudget, [Budget] ) VAR varCountEmpOnProject = CALCULATE ( COUNTROWS ( BridgeEmployeeEngagement ), REMOVEFILTERS ( DimEmployee ) ) VAR BudgetCumulated = CALCULATE ( [Budget], REMOVEFILTERS ( DimDate ), DimDate[YearMonthKey] <= varYearMonthKey ) VAR varBudgetAllocation = DIVIDE ( varBudget, varCountEmpOnProject ) RETURN ROW ( \"@Revenue\", varRevenue, \"@Budget\", varBudget, \"@CountEmpOnProject\", varCountEmpOnProject, \"@BudgetCumulated\", BudgetCumulated, \"@BudgetAllocation\", varBudgetAllocation ) ) VAR Result = SUMX ( FILTER ( tblGenerate, [YearMonthKey] >= minYearMonthKey && [YearMonthKey] <= maxYearMonthKey ), [@BudgetAllocation] ) RETURN Result Result","title":"Budget Allocation"},{"location":"04-PracticalExamples/02_BudgetAllocation/#budget-allocation","text":"When distributing budget, it often happens that the granularity of the data differs. As in our example, an employee enters the hours or the revenue on a daily key. The budget, on the other hand, is planned only per engagement on a monthly key. The budget should now be broken down to the employees who are on the Engagement at the time.","title":"Budget Allocation"},{"location":"04-PracticalExamples/02_BudgetAllocation/#preparation","text":"A fact table is needed, which assigns a monthly budget to each engagement. With the help of a bridge table, the employees are then assigned to the respective projects. model view","title":"Preparation"},{"location":"04-PracticalExamples/02_BudgetAllocation/#implementation","text":"For the implementation it is important that the budget that has already been distributed is also taken into account. In the following example, two employees are in the first month on the engagement, so these two can share the budget. In the third month, another colleague is added. Now, of course, this must not be taken into account for the first month. Therefore, only the open budget from month 2 may still be distributed BudgetAllocation = VAR Employee = SELECTEDVALUE ( DimEmployee[EmployeeKey] ) VAR Engagement = SELECTEDVALUE ( DimEnagement[EngagementCode] ) VAR maxYearMonthKey = MAX ( DimDate[YearMonthKey] ) VAR minYearMonthKey = MIN ( DimDate[YearMonthKey] ) VAR tbl = DISTINCT ( SELECTCOLUMNS ( CALCULATETABLE ( DimDate, DimDate[YearMonthKey] <= maxYearMonthKey ), \"DimDate[YearMonthKey]\", DimDate[YearMonthKey] ) ) VAR tblDateEngEmp = CROSSJOIN ( CROSSJOIN ( tbl, VALUES ( DimEmployee[EmployeeKey] ) ), VALUES ( DimEnagement[EngagementCode] ) ) VAR tblGenerate = GENERATE ( tblDateEngEmp, VAR varYearMonthKey = [YearMonthKey] VAR varEmployeeKey = [EmployeeKey] VAR varEngagementCode = [EngagementCode] VAR varRevenue = [Revenue] VAR EmployeeAllocatedBudget = COUNTROWS ( CALCULATETABLE ( BridgeEmployeeEngagement, DimEmployee[EmployeeKey] = varEmployeeKey, DimEnagement[EngagementCode] = varEngagementCode, DimDate[YearMonthKey] = varYearMonthKey ) ) VAR varBudget = IF ( EmployeeAllocatedBudget, [Budget] ) VAR varCountEmpOnProject = CALCULATE ( COUNTROWS ( BridgeEmployeeEngagement ), REMOVEFILTERS ( DimEmployee ) ) VAR BudgetCumulated = CALCULATE ( [Budget], REMOVEFILTERS ( DimDate ), DimDate[YearMonthKey] <= varYearMonthKey ) VAR varBudgetAllocation = DIVIDE ( varBudget, varCountEmpOnProject ) RETURN ROW ( \"@Revenue\", varRevenue, \"@Budget\", varBudget, \"@CountEmpOnProject\", varCountEmpOnProject, \"@BudgetCumulated\", BudgetCumulated, \"@BudgetAllocation\", varBudgetAllocation ) ) VAR Result = SUMX ( FILTER ( tblGenerate, [YearMonthKey] >= minYearMonthKey && [YearMonthKey] <= maxYearMonthKey ), [@BudgetAllocation] ) RETURN Result","title":"Implementation"},{"location":"04-PracticalExamples/02_BudgetAllocation/#result","text":"","title":"Result"},{"location":"04-PracticalExamples/03_CumulativeBonus/","text":"Cumulative Bonus In this case, we would like to calculate an individual bonus for each employee. The accumulated revenue in a certain period is taken into account. Depending on the exceeded limit, the employee then receives a bonus retrospectively for all sales. Preparation For the conversion, an additional table is required in which the bonus rate and the time periods for each employee are maintained. Implementation The calculation is done as a calculated column in the FactRevenue table. This then assigns the corresponding bonus to each turnover based on the calculated percentage rate. Required Measures Bonus Border From BonusDateFrom = VAR selectedDate = SELECTEDVALUE ( FactRevenue[DateKey] ) VAR selectedEmployee = SELECTEDVALUE ( FactRevenue[EmployeeKey] ) VAR Result = CALCULATE ( MAX ( FactBonus[EffectiveFromDateKey] ), FILTER ( FactBonus, ( FactBonus[EmployeeKey] = selectedEmployee || FactBonus[EmployeeKey] = \"EMP00\" ) && FactBonus[EffectiveFromDateKey] <= selectedDate && FactBonus[EffectiveToDateKey] >= selectedDate ) ) RETURN Result Bonus Border To BonusDateTo = VAR selectedDate = SELECTEDVALUE ( FactRevenue[DateKey] ) VAR selectedEmployee = SELECTEDVALUE ( FactRevenue[EmployeeKey] ) VAR Result = CALCULATE ( MIN ( FactBonus[EffectiveToDateKey] ), FILTER ( FactBonus, ( FactBonus[EmployeeKey] = selectedEmployee || FactBonus[EmployeeKey] = \"EMP00\" ) && FactBonus[EffectiveFromDateKey] <= selectedDate && FactBonus[EffectiveToDateKey] >= selectedDate ) ) RETURN Result Cumulative Revenue within borders CumlativeRevenue = var selectedEmployee = SELECTEDVALUE(FactRevenue[EmployeeKey]) RETURN IF( ISBLANK([BonusDateFrom]) || ISBLANK([BonusDateTo]), BLANK(), CALCULATE( [Revenue], FILTER( ALL(FactRevenue), FactRevenue[EmployeeKey] = selectedEmployee && FactRevenue[DateKey] >= [BonusDateFrom] && FactRevenue[DateKey] <= [BonusDateTo] ) ) ) Bonus Percentage based on the cumulative Revenue BonusPercentage = var DateFrom = [BonusDateFrom] var DateTo = [BonusDateTo] var CumulativeSales = [CumlativeRevenue] var selectedEmployee = SELECTEDVALUE(FactRevenue[EmployeeKey]) RETURN IF( NOT(ISBLANK(DateFrom)||ISBLANK(DateTo)), CALCULATE( MAX(FactBonus[Bonus]), FILTER( FactBonus, FactBonus[BonusDateFrom]=DateFrom && FactBonus[BonusDateTo]=DateTo && (FactBonus[EmployeeKey] = selectedEmployee || FactBonus[EmployeeKey] = \"EMP00\" ) && FactBonus[RevenueFrom]<=CumulativeSales && FactBonus[RevenueTo]>= CumulativeSales ) ) ) Employee Bonus is a simple sum of the calculated column EmployeeBonus = sum(FactRevenue[cEmployeeBonus])","title":"Cumulative Bonus"},{"location":"04-PracticalExamples/03_CumulativeBonus/#cumulative-bonus","text":"In this case, we would like to calculate an individual bonus for each employee. The accumulated revenue in a certain period is taken into account. Depending on the exceeded limit, the employee then receives a bonus retrospectively for all sales.","title":"Cumulative Bonus"},{"location":"04-PracticalExamples/03_CumulativeBonus/#preparation","text":"For the conversion, an additional table is required in which the bonus rate and the time periods for each employee are maintained.","title":"Preparation"},{"location":"04-PracticalExamples/03_CumulativeBonus/#implementation","text":"The calculation is done as a calculated column in the FactRevenue table. This then assigns the corresponding bonus to each turnover based on the calculated percentage rate.","title":"Implementation"},{"location":"04-PracticalExamples/03_CumulativeBonus/#required-measures","text":"Bonus Border From BonusDateFrom = VAR selectedDate = SELECTEDVALUE ( FactRevenue[DateKey] ) VAR selectedEmployee = SELECTEDVALUE ( FactRevenue[EmployeeKey] ) VAR Result = CALCULATE ( MAX ( FactBonus[EffectiveFromDateKey] ), FILTER ( FactBonus, ( FactBonus[EmployeeKey] = selectedEmployee || FactBonus[EmployeeKey] = \"EMP00\" ) && FactBonus[EffectiveFromDateKey] <= selectedDate && FactBonus[EffectiveToDateKey] >= selectedDate ) ) RETURN Result Bonus Border To BonusDateTo = VAR selectedDate = SELECTEDVALUE ( FactRevenue[DateKey] ) VAR selectedEmployee = SELECTEDVALUE ( FactRevenue[EmployeeKey] ) VAR Result = CALCULATE ( MIN ( FactBonus[EffectiveToDateKey] ), FILTER ( FactBonus, ( FactBonus[EmployeeKey] = selectedEmployee || FactBonus[EmployeeKey] = \"EMP00\" ) && FactBonus[EffectiveFromDateKey] <= selectedDate && FactBonus[EffectiveToDateKey] >= selectedDate ) ) RETURN Result Cumulative Revenue within borders CumlativeRevenue = var selectedEmployee = SELECTEDVALUE(FactRevenue[EmployeeKey]) RETURN IF( ISBLANK([BonusDateFrom]) || ISBLANK([BonusDateTo]), BLANK(), CALCULATE( [Revenue], FILTER( ALL(FactRevenue), FactRevenue[EmployeeKey] = selectedEmployee && FactRevenue[DateKey] >= [BonusDateFrom] && FactRevenue[DateKey] <= [BonusDateTo] ) ) ) Bonus Percentage based on the cumulative Revenue BonusPercentage = var DateFrom = [BonusDateFrom] var DateTo = [BonusDateTo] var CumulativeSales = [CumlativeRevenue] var selectedEmployee = SELECTEDVALUE(FactRevenue[EmployeeKey]) RETURN IF( NOT(ISBLANK(DateFrom)||ISBLANK(DateTo)), CALCULATE( MAX(FactBonus[Bonus]), FILTER( FactBonus, FactBonus[BonusDateFrom]=DateFrom && FactBonus[BonusDateTo]=DateTo && (FactBonus[EmployeeKey] = selectedEmployee || FactBonus[EmployeeKey] = \"EMP00\" ) && FactBonus[RevenueFrom]<=CumulativeSales && FactBonus[RevenueTo]>= CumulativeSales ) ) ) Employee Bonus is a simple sum of the calculated column EmployeeBonus = sum(FactRevenue[cEmployeeBonus])","title":"Required Measures"},{"location":"04-PracticalExamples/04_TrendAnalysis/","text":"Custom Trend Analysis In this example, we want to determine a trend. The logic applied is quite simple, we divide the evaluation into two equal periods. If the second half performs better than the first, we assume a positive trend. As a return value we do not want a number but an arrow as a symbol. We would like to keep the period which is to be evaluated flexible and should therefore be adaptable in the report. Preparation At the beginning we need a table with which we can later select the flexible monthly period DimFilterN = GENERATESERIES(1,30,1) In order to be able to validate the results later, we would like to show the timeline of the revenue for the selected months completely, even though a specific month was selected in the report. To achieve this, we create a second date dimension that has an indirect relationship to the actual date dimension. Using a Calculation Group we then set the relationship to override the selected time period of the date dimension. VAR NumOfMonths = SELECTEDVALUE ( 'DimFilterN'[Value] ) * ( -1 ) VAR ReferenceDate = MAX ( 'DimDate'[Date] ) VAR PreviousDates = DATESINPERIOD ( 'PreviousDate'[Date], ReferenceDate, NumOfMonths, MONTH ) VAR Result = CALCULATE ( SELECTEDMEASURE (), REMOVEFILTERS ( 'DimDate' ), KEEPFILTERS ( PreviousDates ), USERELATIONSHIP ( 'PreviousDate'[DateKey], 'DimDate'[DateKey] ) ) RETURN Result Implementation Trend Measures divides the selected period in two timeframes and calculates the average revenue for both. Finally, both are compared. If the latter period shows a higher average, we assume a positive trend. Trend = VAR SelectedMonthValue = SELECTEDVALUE ( DimFilterN[Value] ) VAR CurrentYearMonth = SELECTEDVALUE ( DimDate[YearMonthKey] ) VAR LastNMonthRevenue = FILTER ( CALCULATETABLE ( TOPN ( SelectedMonthValue, ADDCOLUMNS ( VALUES ( DimDate[YearMonthKey] ), \"tempRevenue\", [Revenue] ), DimDate[YearMonthKey], DESC ), DimDate[YearMonthKey] <= CurrentYearMonth, REMOVEFILTERS ( DimDate ) ), [tempRevenue] <> BLANK () ) VAR WeeksInRange = COUNTROWS ( SUMMARIZE ( LastNMonthRevenue, [YearMonthKey] ) ) VAR FirstHalfAvg = AVERAGEX ( TOPN ( INT ( WeeksInRange / 2 ), LastNMonthRevenue, [YearMonthKey], ASC ), [tempRevenue] ) VAR SecondHalfAvg = AVERAGEX ( TOPN ( INT ( WeeksInRange / 2 ), LastNMonthRevenue, [YearMonthKey], DESC ), [tempRevenue] ) VAR growthRate = DIVIDE ( FirstHalfAvg, SecondHalfAvg ) VAR Result = IF ( NOT ISBLANK ( growthRate ), IF ( growthRate > 1, \"\u2193\", IF ( growthRate < 1, \"\u2191\", \"\u2192\" ) ) ) RETURN Result Result","title":"Custom Trend Analysis"},{"location":"04-PracticalExamples/04_TrendAnalysis/#custom-trend-analysis","text":"In this example, we want to determine a trend. The logic applied is quite simple, we divide the evaluation into two equal periods. If the second half performs better than the first, we assume a positive trend. As a return value we do not want a number but an arrow as a symbol. We would like to keep the period which is to be evaluated flexible and should therefore be adaptable in the report.","title":"Custom Trend Analysis"},{"location":"04-PracticalExamples/04_TrendAnalysis/#preparation","text":"At the beginning we need a table with which we can later select the flexible monthly period DimFilterN = GENERATESERIES(1,30,1) In order to be able to validate the results later, we would like to show the timeline of the revenue for the selected months completely, even though a specific month was selected in the report. To achieve this, we create a second date dimension that has an indirect relationship to the actual date dimension. Using a Calculation Group we then set the relationship to override the selected time period of the date dimension. VAR NumOfMonths = SELECTEDVALUE ( 'DimFilterN'[Value] ) * ( -1 ) VAR ReferenceDate = MAX ( 'DimDate'[Date] ) VAR PreviousDates = DATESINPERIOD ( 'PreviousDate'[Date], ReferenceDate, NumOfMonths, MONTH ) VAR Result = CALCULATE ( SELECTEDMEASURE (), REMOVEFILTERS ( 'DimDate' ), KEEPFILTERS ( PreviousDates ), USERELATIONSHIP ( 'PreviousDate'[DateKey], 'DimDate'[DateKey] ) ) RETURN Result","title":"Preparation"},{"location":"04-PracticalExamples/04_TrendAnalysis/#implementation","text":"Trend Measures divides the selected period in two timeframes and calculates the average revenue for both. Finally, both are compared. If the latter period shows a higher average, we assume a positive trend. Trend = VAR SelectedMonthValue = SELECTEDVALUE ( DimFilterN[Value] ) VAR CurrentYearMonth = SELECTEDVALUE ( DimDate[YearMonthKey] ) VAR LastNMonthRevenue = FILTER ( CALCULATETABLE ( TOPN ( SelectedMonthValue, ADDCOLUMNS ( VALUES ( DimDate[YearMonthKey] ), \"tempRevenue\", [Revenue] ), DimDate[YearMonthKey], DESC ), DimDate[YearMonthKey] <= CurrentYearMonth, REMOVEFILTERS ( DimDate ) ), [tempRevenue] <> BLANK () ) VAR WeeksInRange = COUNTROWS ( SUMMARIZE ( LastNMonthRevenue, [YearMonthKey] ) ) VAR FirstHalfAvg = AVERAGEX ( TOPN ( INT ( WeeksInRange / 2 ), LastNMonthRevenue, [YearMonthKey], ASC ), [tempRevenue] ) VAR SecondHalfAvg = AVERAGEX ( TOPN ( INT ( WeeksInRange / 2 ), LastNMonthRevenue, [YearMonthKey], DESC ), [tempRevenue] ) VAR growthRate = DIVIDE ( FirstHalfAvg, SecondHalfAvg ) VAR Result = IF ( NOT ISBLANK ( growthRate ), IF ( growthRate > 1, \"\u2193\", IF ( growthRate < 1, \"\u2191\", \"\u2192\" ) ) ) RETURN Result","title":"Implementation"},{"location":"04-PracticalExamples/04_TrendAnalysis/#result","text":"","title":"Result"},{"location":"04-PracticalExamples/05_ProfitAndLoss/","text":"Profit and Loss The presentation of a profit and loss statement is challenging for a number of reasons. In addition to suitable visualizations, the individual hierarchical structure and calculation is a complex undertaking. Preparation First, we need the desired profit and loss structure as a parent child hierarchy. The operator field indicates whether the values are to be added or subtracted later. Then this table is completed with the following calculated columns. AccountPath = PATH ( PL[AccountKey], PL[ParentAccountKey] ) Depth = PATHLENGTH ( PL[AccountPath] ) Level 1 - 6 SignToLevel1 = VAR LevelNumber = 1 VAR PrevSign = PL[SignToLevel2] VAR Depth = PL[Depth] VAR LevelKey = PATHITEM ( PL[AccountPath], LevelNumber, INTEGER ) VAR LevelSign = LOOKUPVALUE ( PL[Operator], PL[AccountKey], LevelKey ) RETURN IF ( LevelNumber = Depth, IF ( PL[Operator] = \"-\", -1, +1 ), IF ( LevelNumber < Depth, IF ( LevelSign = \"-\", -1, +1 ) * PrevSign ) ) Level 7 (Last Level) SignToLevel7 = VAR LevelNumber = 7 VAR Depth = PL[Depth] RETURN IF ( LevelNumber = Depth, IF ( PL[Operator] = \"-\", -1, +1 ) ) Look Up for Hierarchy Name fields (All Levels) Level1 = VAR LevelNumber = 1 VAR LevelKey = PATHITEM ( PL[AccountPath], LevelNumber, INTEGER ) VAR LevelName = LOOKUPVALUE ( PL[AccountName], PL[AccountKey], LevelKey ) VAR Result = LevelName RETURN Result Implementation Measure for the PL illustration PL Total = VAR BrowseDepth = MAX ( [AccountBrowseDepth], 1 ) VAR AccountShowRow = [AccountBrowseDepth] <= [AccountRowDepth] VAR Result = IF ( AccountShowRow, SWITCH ( BrowseDepth, 1, SUMX ( VALUES ( pl[SignToLevel1] ), [Sum Amount] * pl[SignToLevel1] ), 2, SUMX ( VALUES ( pl[SignToLevel2] ), [Sum Amount] * pl[SignToLevel2] ), 3, SUMX ( VALUES ( pl[SignToLevel3] ), [Sum Amount] * pl[SignToLevel3] ), 4, SUMX ( VALUES ( pl[SignToLevel4] ), [Sum Amount] * pl[SignToLevel4] ), 5, SUMX ( VALUES ( pl[SignToLevel5] ), [Sum Amount] * pl[SignToLevel5] ), 6, SUMX ( VALUES ( pl[SignToLevel6] ), [Sum Amount] * pl[SignToLevel6] ), 7, SUMX ( VALUES ( pl[SignToLevel7] ), [Sum Amount] * pl[SignToLevel7] ) ) ) RETURN Result Result","title":"Profit and Loss"},{"location":"04-PracticalExamples/05_ProfitAndLoss/#profit-and-loss","text":"The presentation of a profit and loss statement is challenging for a number of reasons. In addition to suitable visualizations, the individual hierarchical structure and calculation is a complex undertaking.","title":"Profit and Loss"},{"location":"04-PracticalExamples/05_ProfitAndLoss/#preparation","text":"First, we need the desired profit and loss structure as a parent child hierarchy. The operator field indicates whether the values are to be added or subtracted later. Then this table is completed with the following calculated columns. AccountPath = PATH ( PL[AccountKey], PL[ParentAccountKey] ) Depth = PATHLENGTH ( PL[AccountPath] ) Level 1 - 6 SignToLevel1 = VAR LevelNumber = 1 VAR PrevSign = PL[SignToLevel2] VAR Depth = PL[Depth] VAR LevelKey = PATHITEM ( PL[AccountPath], LevelNumber, INTEGER ) VAR LevelSign = LOOKUPVALUE ( PL[Operator], PL[AccountKey], LevelKey ) RETURN IF ( LevelNumber = Depth, IF ( PL[Operator] = \"-\", -1, +1 ), IF ( LevelNumber < Depth, IF ( LevelSign = \"-\", -1, +1 ) * PrevSign ) ) Level 7 (Last Level) SignToLevel7 = VAR LevelNumber = 7 VAR Depth = PL[Depth] RETURN IF ( LevelNumber = Depth, IF ( PL[Operator] = \"-\", -1, +1 ) ) Look Up for Hierarchy Name fields (All Levels) Level1 = VAR LevelNumber = 1 VAR LevelKey = PATHITEM ( PL[AccountPath], LevelNumber, INTEGER ) VAR LevelName = LOOKUPVALUE ( PL[AccountName], PL[AccountKey], LevelKey ) VAR Result = LevelName RETURN Result","title":"Preparation"},{"location":"04-PracticalExamples/05_ProfitAndLoss/#implementation","text":"Measure for the PL illustration PL Total = VAR BrowseDepth = MAX ( [AccountBrowseDepth], 1 ) VAR AccountShowRow = [AccountBrowseDepth] <= [AccountRowDepth] VAR Result = IF ( AccountShowRow, SWITCH ( BrowseDepth, 1, SUMX ( VALUES ( pl[SignToLevel1] ), [Sum Amount] * pl[SignToLevel1] ), 2, SUMX ( VALUES ( pl[SignToLevel2] ), [Sum Amount] * pl[SignToLevel2] ), 3, SUMX ( VALUES ( pl[SignToLevel3] ), [Sum Amount] * pl[SignToLevel3] ), 4, SUMX ( VALUES ( pl[SignToLevel4] ), [Sum Amount] * pl[SignToLevel4] ), 5, SUMX ( VALUES ( pl[SignToLevel5] ), [Sum Amount] * pl[SignToLevel5] ), 6, SUMX ( VALUES ( pl[SignToLevel6] ), [Sum Amount] * pl[SignToLevel6] ), 7, SUMX ( VALUES ( pl[SignToLevel7] ), [Sum Amount] * pl[SignToLevel7] ) ) ) RETURN Result","title":"Implementation"},{"location":"04-PracticalExamples/05_ProfitAndLoss/#result","text":"","title":"Result"}]}